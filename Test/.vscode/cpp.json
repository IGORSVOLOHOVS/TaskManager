{
    "Task Helper and Index": {
        "prefix": "task_help",
        "body": [
            "// --- GoF Pattern Combinations & Snippet Index ---",
            "//",
            "// Common Combinations:",
            "// - Abstract Factory + Factory Method: Factories often use Factory Methods.",
            "// - Builder + Composite: Builder can construct complex Composite trees.",
            "// - Command + Memento: Command can use Memento for undo/redo.",
            "// - Composite + Iterator: Iterator traverses a Composite.",
            "// - Composite + Visitor: Visitor performs operations on a Composite.",
            "// - Decorator + Adapter: Decorator adds functionality, Adapter changes interface.",
            "// - Strategy + State: Both manage behavior based on context.",
            "// - Template Method + Factory Method: Template Method can call Factory Methods.",
            "//",
            "// Snippet Prefixes (GoF):",
            "//   Creational:",
            "//     gof_singleton          (Singleton)",
            "//     gof_factory_method     (Factory Method)",
            "//     gof_abstract_factory   (Abstract Factory)",
            "//     gof_builder            (Builder)",
            "//     gof_prototype          (Prototype)",
            "//   Structural:",
            "//     gof_adapter            (Adapter)",
            "//     gof_bridge             (Bridge)",
            "//     gof_composite          (Composite)",
            "//     gof_decorator          (Decorator)",
            "//     gof_facade             (Facade)",
            "//     gof_flyweight          (Flyweight)",
            "//     gof_proxy              (Proxy)",
            "//   Behavioral:",
            "//     gof_chain_of_responsibility (Chain of Responsibility)",
            "//     gof_command            (Command)",
            "//     gof_interpreter        (Interpreter)",
            "//     gof_iterator           (Iterator)",
            "//     gof_mediator           (Mediator)",
            "//     gof_memento            (Memento)",
            "//     gof_state              (State)",
            "//     gof_strategy           (Strategy)",
            "//     gof_template_method    (Template Method)",
            "//     gof_visitor            (Visitor)",
            "//",
            "// Utility Snippets:",
            "//     task_5constructors     (Default/Copy/Move Constructors/Assignment & Destructor)",
            "//     task_u                 (std::unique_ptr<Type>)",
            "//     task_s                 (std::shared_ptr<Type>)",
            "//     task_r                 (std::vector<double>)",
            "//     task_i                 (std::vector<int>)",
            "//     task_str               (std::vector<std::string>)",
            "//",
            "// Function Definition Snippets:",
            "//     task_func_rnd_vec_double (Function: Generate Random Doubles Vector)",
            "//     task_func_rnd_vec_int    (Function: Generate Random Integers Vector)",
            "//     task_func_rnd_vec_str    (Function: Generate Random Strings Vector)",
            "//     task_func_measure_time   (Function: Measure execution time of a lambda)",
            "//     task_func_sleep_ms       (Function: Sleep for milliseconds)",
            "//     task_func_logger         (Function: Simple Logger)",
            "//",
            "// Notes:",
            "// - Assumes C++17+ for some features like [[nodiscard]] and std::make_unique.",
            "// - Most patterns returning objects now use std::unique_ptr for ownership management.",
            "// - Remember to #include necessary headers like <memory>, <vector>, <string>, <iostream>, etc.",
            "// - For C++23 specific features, ensure your compiler (e.g., GCC 13+, Clang 17+) supports them."
        ],
        "description": "Helper comment with pattern combinations and snippet index."
    },
    "GOF_Singleton": {
        "prefix": "gof_singleton",
        "body": [
            "class ${1:Singleton} final {",
            "public:",
            "    [[nodiscard]] static ${1:Singleton}& getInstance() {",
            "        static ${1:Singleton} instance;",
            "        return instance;",
            "    }",
            "    void doSomething() { /* ... */ }",
            "    ${1:Singleton}(const ${1:Singleton}&) = delete;",
            "    ${1:Singleton}& operator=(const ${1:Singleton}&) = delete;",
            "    ${1:Singleton}(${1:Singleton}&&) = delete;",
            "    ${1:Singleton}& operator=(${1:Singleton}&&) = delete;",
            "private:",
            "    ${1:Singleton}() = default;",
            "    ~${1:Singleton}() = default;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// struct MySingleton {",
            "// public:",
            "//     [[nodiscard]] static MySingleton& getInstance() { static MySingleton instance; return instance; }",
            "//     void operation() { std::cout << \"MySingleton operation\\n\"; }",
            "//     MySingleton(const MySingleton&) = delete;",
            "//     MySingleton& operator=(const MySingleton&) = delete;",
            "//     MySingleton(MySingleton&&) = delete;",
            "//     MySingleton& operator=(MySingleton&&) = delete;",
            "// private:",
            "//     MySingleton() { std::cout << \"MySingleton created\\n\"; }",
            "//     ~MySingleton() { std::cout << \"MySingleton destroyed\\n\"; }",
            "// };",
            "// int main() {",
            "//    MySingleton& instance = MySingleton::getInstance();",
            "//    instance.operation();",
            "//    MySingleton& another_instance = MySingleton::getInstance(); // Same instance",
            "//    another_instance.operation();",
            "//    return 0;",
            "// }"
        ],
        "description": "Singleton design pattern (Meyers' Singleton, C++11 thread-safe)"
    },
    "GOF_FactoryMethod": {
        "prefix": "gof_factory_method",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    virtual ~${1:Product}() = default;",
            "    virtual void use() = 0;",
            "};",
            "class ${2:ConcreteProductA} : public ${1:Product} { public: void use() override { /* Impl A */ } };",
            "class ${3:ConcreteProductB} : public ${1:Product} { public: void use() override { /* Impl B */ } };",
            "class ${4:Creator} {",
            "public:",
            "    virtual ~${4:Creator}() = default;",
            "    [[nodiscard]] virtual std::unique_ptr<${1:Product}> createProduct() = 0;",
            "    void someOperation() {",
            "        std::unique_ptr<${1:Product}> product = createProduct();",
            "        product->use();",
            "    }",
            "};",
            "class ${5:ConcreteCreatorA} : public ${4:Creator} {",
            "public:",
            "    [[nodiscard]] std::unique_ptr<${1:Product}> createProduct() override { return std::make_unique<${2:ConcreteProductA}>(); }",
            "};",
            "class ${6:ConcreteCreatorB} : public ${4:Creator} {",
            "public:",
            "    [[nodiscard]] std::unique_ptr<${1:Product}> createProduct() override { return std::make_unique<${3:ConcreteProductB}>(); }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// #include <string>",
            "// abstract class Button { public: virtual ~Button() = default; virtual void render() = 0; virtual void onClick() = 0; };",
            "// class WindowsButton : public Button { public: void render() override { std::cout << \"Rendering Windows button.\\n\"; } void onClick() override { std::cout << \"Windows button clicked.\\n\"; } };",
            "// class MacButton : public Button { public: void render() override { std::cout << \"Rendering Mac button.\\n\"; } void onClick() override { std::cout << \"Mac button clicked.\\n\"; } };",
            "// abstract class Dialog { public: virtual ~Dialog() = default; [[nodiscard]] virtual std::unique_ptr<Button> createButton() = 0; void renderDialog() { std::unique_ptr<Button> okButton = createButton(); okButton->render(); okButton->onClick(); } };",
            "// class WindowsDialog : public Dialog { public: [[nodiscard]] std::unique_ptr<Button> createButton() override { return std::make_unique<WindowsButton>(); } };",
            "// class MacDialog : public Dialog { public: [[nodiscard]] std::unique_ptr<Button> createButton() override { return std::make_unique<MacButton>(); } };",
            "// int main() {",
            "//    std::unique_ptr<Dialog> dialog;",
            "//    #if defined(_WIN32)",
            "//        dialog = std::make_unique<WindowsDialog>();",
            "//    #elif defined(__APPLE__)",
            "//        dialog = std::make_unique<MacDialog>();",
            "//    #else",
            "//        std::cout << \"Unknown OS, using default (Windows) dialog.\\n\";",
            "//        dialog = std::make_unique<WindowsDialog>();",
            "//    #endif",
            "//    if(dialog) dialog->renderDialog();",
            "//    return 0;",
            "// }"
        ],
        "description": "Factory Method design pattern"
    },
    "GOF_AbstractFactory": {
        "prefix": "gof_abstract_factory",
        "body": [
            "class ${1:AbstractProductA} { public: virtual ~${1:AbstractProductA}() = default; virtual void useA() = 0; };",
            "class ${2:AbstractProductB} { public: virtual ~${2:AbstractProductB}() = default; virtual void useB() = 0; };",
            "class ${3:ConcreteProductA1} : public ${1:AbstractProductA} { public: void useA() override { /* Impl A1 */ } };",
            "class ${4:ConcreteProductA2} : public ${1:AbstractProductA} { public: void useA() override { /* Impl A2 */ } };",
            "class ${5:ConcreteProductB1} : public ${2:AbstractProductB} { public: void useB() override { /* Impl B1 */ } };",
            "class ${6:ConcreteProductB2} : public ${2:AbstractProductB} { public: void useB() override { /* Impl B2 */ } };",
            "class ${7:AbstractFactory} {",
            "public:",
            "    virtual ~${7:AbstractFactory}() = default;",
            "    [[nodiscard]] virtual std::unique_ptr<${1:AbstractProductA}> createProductA() = 0;",
            "    [[nodiscard]] virtual std::unique_ptr<${2:AbstractProductB}> createProductB() = 0;",
            "};",
            "class ${8:ConcreteFactory1} : public ${7:AbstractFactory} {",
            "public:",
            "    [[nodiscard]] std::unique_ptr<${1:AbstractProductA}> createProductA() override { return std::make_unique<${3:ConcreteProductA1}>(); }",
            "    [[nodiscard]] std::unique_ptr<${2:AbstractProductB}> createProductB() override { return std::make_unique<${5:ConcreteProductB1}>(); }",
            "};",
            "class ${9:ConcreteFactory2} : public ${7:AbstractFactory} {",
            "public:",
            "    [[nodiscard]] std::unique_ptr<${1:AbstractProductA}> createProductA() override { return std::make_unique<${4:ConcreteProductA2}>(); }",
            "    [[nodiscard]] std::unique_ptr<${2:AbstractProductB}> createProductB() override { return std::make_unique<${6:ConcreteProductB2}>(); }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// #include <string>",
            "// // Abstract Products for GUI elements",
            "// class Button { public: virtual ~Button() = default; virtual void paint() = 0; };",
            "// class Checkbox { public: virtual ~Checkbox() = default; virtual void paint() = 0; };",
            "// // Concrete Products for Windows style",
            "// class WinButton : public Button { public: void paint() override { std::cout << \"Painting Windows Button.\\n\"; } };",
            "// class WinCheckbox : public Checkbox { public: void paint() override { std::cout << \"Painting Windows Checkbox.\\n\"; } };",
            "// // Concrete Products for Mac style",
            "// class MacButton : public Button { public: void paint() override { std::cout << \"Painting Mac Button.\\n\"; } };",
            "// class MacCheckbox : public Checkbox { public: void paint() override { std::cout << \"Painting Mac Checkbox.\\n\"; } };",
            "// // Abstract Factory for GUI",
            "// class GUIFactory { public: virtual ~GUIFactory() = default; [[nodiscard]] virtual std::unique_ptr<Button> createButton() = 0; [[nodiscard]] virtual std::unique_ptr<Checkbox> createCheckbox() = 0; };",
            "// // Concrete Factory for Windows style",
            "// class WinFactory : public GUIFactory { public: [[nodiscard]] std::unique_ptr<Button> createButton() override { return std::make_unique<WinButton>(); } [[nodiscard]] std::unique_ptr<Checkbox> createCheckbox() override { return std::make_unique<WinCheckbox>(); } };",
            "// // Concrete Factory for Mac style",
            "// class MacFactory : public GUIFactory { public: [[nodiscard]] std::unique_ptr<Button> createButton() override { return std::make_unique<MacButton>(); } [[nodiscard]] std::unique_ptr<Checkbox> createCheckbox() override { return std::make_unique<MacCheckbox>(); } };",
            "// // Client code that uses the factory",
            "// class Application {",
            "// private: std::unique_ptr<GUIFactory> factory_; std::unique_ptr<Button> button_; std::unique_ptr<Checkbox> checkbox_;",
            "// public: Application(std::unique_ptr<GUIFactory> factory) : factory_(std::move(factory)) {} ",
            "//         void createUI() { button_ = factory_->createButton(); checkbox_ = factory_->createCheckbox(); }",
            "//         void paintUI() { if(button_) button_->paint(); if(checkbox_) checkbox_->paint(); }",
            "// };",
            "// int main() {",
            "//    std::unique_ptr<GUIFactory> factory;",
            "//    #if defined(_WIN32) || defined(_WIN64)",
            "//        factory = std::make_unique<WinFactory>();",
            "//    #elif defined(__APPLE__) && defined(__MACH__)",
            "//        factory = std::make_unique<MacFactory>();",
            "//    #else",
            "//        std::cout << \"Unknown OS, defaulting to Windows style.\\n\"; factory = std::make_unique<WinFactory>();",
            "//    #endif",
            "//    Application app(std::move(factory));",
            "//    app.createUI(); app.paintUI();",
            "//    return 0;",
            "// }"
        ],
        "description": "Abstract Factory design pattern"
    },
    "GOF_Builder": {
        "prefix": "gof_builder",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    void setPartA(const std::string& partA) { partA_ = partA; }",
            "    void setPartB(const std::string& partB) { partB_ = partB; }",
            "    void listParts() const { /* std::cout << partA_ << partB_ << ... */ }",
            "private: std::string partA_; std::string partB_; /* ... more parts */",
            "};",
            "class ${2:Builder} {",
            "public:",
            "    virtual ~${2:Builder}() = default;",
            "    virtual void buildPartA() = 0;",
            "    virtual void buildPartB() = 0;",
            "    /* ... more build steps ... */",
            "    [[nodiscard]] virtual std::unique_ptr<${1:Product}> getProduct() = 0;",
            "};",
            "class ${3:ConcreteBuilder} : public ${2:Builder} {",
            "public:",
            "    ${3:ConcreteBuilder}() { reset(); }",
            "    void reset() { product_ = std::make_unique<${1:Product}>(); }",
            "    void buildPartA() override { product_->setPartA(\"PartA_Impl\"); }",
            "    void buildPartB() override { product_->setPartB(\"PartB_Impl\"); }",
            "    [[nodiscard]] std::unique_ptr<${1:Product}> getProduct() override { ",
            "        std::unique_ptr<${1:Product}> result = std::move(product_); ",
            "        reset(); return result; ",
            "    }",
            "private: std::unique_ptr<${1:Product}> product_;",
            "};",
            "class ${4:Director} {",
            "public:",
            "    void setBuilder(${2:Builder}* builder) { builder_ = builder; }",
            "    [[nodiscard]] std::unique_ptr<${1:Product}> constructSimpleProduct() { builder_->buildPartA(); return builder_->getProduct(); }",
            "    [[nodiscard]] std::unique_ptr<${1:Product}> constructFullProduct() { builder_->buildPartA(); builder_->buildPartB(); return builder_->getProduct(); }",
            "private: ${2:Builder}* builder_ = nullptr;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// #include <vector>",
            "// class Pizza {",
            "// public:",
            "//     void setDough(const std::string& dough) { dough_ = dough; }",
            "//     void setSauce(const std::string& sauce) { sauce_ = sauce; }",
            "//     void addTopping(const std::string& topping) { toppings_.push_back(topping); }",
            "//     void describe() const { std::cout << \"Pizza with \" << dough_ << \" dough, \" << sauce_ << \" sauce, and toppings: \"; for(const auto& t : toppings_) std::cout << t << \" \"; std::cout << \"\\n\"; }",
            "// private: std::string dough_; std::string sauce_; std::vector<std::string> toppings_;",
            "// };",
            "// class PizzaBuilder {",
            "// public: virtual ~PizzaBuilder() = default; virtual void buildDough() = 0; virtual void buildSauce() = 0; virtual void buildToppings() = 0; [[nodiscard]] virtual std::unique_ptr<Pizza> getPizza() = 0;",
            "// };",
            "// class MargheritaPizzaBuilder : public PizzaBuilder {",
            "// private: std::unique_ptr<Pizza> pizza_;",
            "// public: MargheritaPizzaBuilder() { pizza_ = std::make_unique<Pizza>(); }",
            "//         void buildDough() override { pizza_->setDough(\"thin crust\"); }",
            "//         void buildSauce() override { pizza_->setSauce(\"tomato\"); }",
            "//         void buildToppings() override { pizza_->addTopping(\"mozzarella\"); pizza_->addTopping(\"basil\"); }",
            "//         [[nodiscard]] std::unique_ptr<Pizza> getPizza() override { return std::move(pizza_); }",
            "// };",
            "// class SpicyPizzaBuilder : public PizzaBuilder {",
            "// private: std::unique_ptr<Pizza> pizza_;",
            "// public: SpicyPizzaBuilder() { pizza_ = std::make_unique<Pizza>(); }",
            "//        void buildDough() override { pizza_->setDough(\"thick crust\"); }",
            "//        void buildSauce() override { pizza_->setSauce(\"spicy tomato\"); }",
            "//        void buildToppings() override { pizza_->addTopping(\"pepperoni\"); pizza_->addTopping(\"jalapenos\"); }",
            "//        [[nodiscard]] std::unique_ptr<Pizza> getPizza() override { return std::move(pizza_); }",
            "// };",
            "// class Waiter { // Director",
            "// private: PizzaBuilder* pizzaBuilder_ = nullptr;",
            "// public: void setPizzaBuilder(PizzaBuilder* builder) { pizzaBuilder_ = builder; }",
            "//         [[nodiscard]] std::unique_ptr<Pizza> makePizza() { if(!pizzaBuilder_) return nullptr; pizzaBuilder_->buildDough(); pizzaBuilder_->buildSauce(); pizzaBuilder_->buildToppings(); return pizzaBuilder_->getPizza(); }",
            "// };",
            "// int main() {",
            "//    Waiter waiter;",
            "//    MargheritaPizzaBuilder margheritaBuilder;",
            "//    waiter.setPizzaBuilder(&margheritaBuilder);",
            "//    std::unique_ptr<Pizza> margherita = waiter.makePizza();",
            "//    if(margherita) margherita->describe();",
            "//",
            "//    SpicyPizzaBuilder spicyBuilder;",
            "//    waiter.setPizzaBuilder(&spicyBuilder);",
            "//    std::unique_ptr<Pizza> spicy = waiter.makePizza();",
            "//    if(spicy) spicy->describe();",
            "//    return 0;",
            "// }"
        ],
        "description": "Builder design pattern"
    },
    "GOF_Prototype": {
        "prefix": "gof_prototype",
        "body": [
            "class ${1:Prototype} {",
            "public:",
            "    virtual ~${1:Prototype}() = default;",
            "    [[nodiscard]] virtual std::unique_ptr<${1:Prototype}> clone() const = 0;",
            "    virtual void operation(const std::string& data) = 0;",
            "};",
            "class ${2:ConcretePrototypeA} : public ${1:Prototype} {",
            "public:",
            "    ${2:ConcretePrototypeA}(int value) : value_(value) {}",
            "    [[nodiscard]] std::unique_ptr<${1:Prototype}> clone() const override { return std::make_unique<${2:ConcretePrototypeA}>(*this); }",
            "    void operation(const std::string& data) override { /* Use value_ and data */ }",
            "private: int value_;",
            "};",
            "class ${3:ConcretePrototypeB} : public ${1:Prototype} {",
            "public:",
            "    ${3:ConcretePrototypeB}(std::string label) : label_(std::move(label)) {}",
            "    [[nodiscard]] std::unique_ptr<${1:Prototype}> clone() const override { return std::make_unique<${3:ConcretePrototypeB}>(*this); }",
            "    void operation(const std::string& data) override { /* Use label_ and data */ }",
            "private: std::string label_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// #include <vector>",
            "// // Prototype for a shape",
            "// class Shape {",
            "// public: virtual ~Shape() = default; [[nodiscard]] virtual std::unique_ptr<Shape> clone() const = 0; virtual void draw() = 0; std::string id;",
            "// protected: Shape() = default; Shape(const Shape& source) : id(source.id + \"_cloned\") {} };",
            "// // Concrete Prototypes",
            "// class Rectangle : public Shape {",
            "// public: int width, height; Rectangle(int w, int h, std::string id_str) : width(w), height(h) { id = std::move(id_str); }",
            "//         Rectangle(const Rectangle& source) : Shape(source), width(source.width), height(source.height) {} ",
            "//         [[nodiscard]] std::unique_ptr<Shape> clone() const override { return std::make_unique<Rectangle>(*this); }",
            "//         void draw() override { std::cout << \"Drawing Rectangle \" << id << \" (w:\" << width << \", h:\" << height << \")\\n\"; }",
            "// };",
            "// class Circle : public Shape {",
            "// public: int radius; Circle(int r, std::string id_str) : radius(r) { id = std::move(id_str); }",
            "//         Circle(const Circle& source) : Shape(source), radius(source.radius) {} ",
            "//         [[nodiscard]] std::unique_ptr<Shape> clone() const override { return std::make_unique<Circle>(*this); }",
            "//         void draw() override { std::cout << \"Drawing Circle \" << id << \" (r:\" << radius << \")\\n\"; }",
            "// };",
            "// int main() {",
            "//    std::vector<std::unique_ptr<Shape>> shapes;",
            "//    auto originalRect = std::make_unique<Rectangle>(10, 20, \"Rect1\");",
            "//    auto originalCirc = std::make_unique<Circle>(5, \"Circ1\");",
            "//    shapes.push_back(originalRect->clone());",
            "//    shapes.push_back(originalCirc->clone());",
            "//    shapes.push_back(originalRect->clone()); // Another clone of originalRect",
            "//    shapes[2]->id = \"Rect3_custom\";",
            "//    for (const auto& shape : shapes) { shape->draw(); }",
            "//    return 0;",
            "// }"
        ],
        "description": "Prototype design pattern"
    },
    "GOF_Adapter": {
        "prefix": "gof_adapter",
        "body": [
            "class ${1:Target} { public: virtual ~${1:Target}() = default; virtual void request() = 0; };",
            "class ${2:Adaptee} { public: void specificRequest() { /* Adaptee's specific behavior */ } };",
            "class ${3:Adapter} : public ${1:Target} {",
            "public:",
            "    ${3:Adapter}(std::shared_ptr<${2:Adaptee}> adaptee) : adaptee_(adaptee) {}",
            "    void request() override { if(adaptee_) adaptee_->specificRequest(); }",
            "private: std::shared_ptr<${2:Adaptee}> adaptee_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// // Target interface for a modern logger",
            "// class ModernLogger { public: virtual ~ModernLogger() = default; virtual void logMessage(const std::string& message) = 0; };",
            "// // Adaptee: an old logging library with a different interface",
            "// class OldLogger { public: void writeEntry(const char* entry) { std::cout << \"OldLogger: \" << entry << std::endl; } };",
            "// // Adapter to make OldLogger compatible with ModernLogger interface",
            "// class LoggerAdapter : public ModernLogger {",
            "// private: std::shared_ptr<OldLogger> oldLogger_;",
            "// public: LoggerAdapter(std::shared_ptr<OldLogger> logger) : oldLogger_(logger) {} ",
            "//         void logMessage(const std::string& message) override { if(oldLogger_) oldLogger_->writeEntry(message.c_str()); }",
            "// };",
            "// // Client code that expects a ModernLogger",
            "// void clientCode(ModernLogger& logger) { logger.logMessage(\"This is a test message.\"); }",
            "// int main() {",
            "//    auto oldLoggerInstance = std::make_shared<OldLogger>();",
            "//    LoggerAdapter adapter(oldLoggerInstance);",
            "//    clientCode(adapter);",
            "//    return 0;",
            "// }"
        ],
        "description": "Adapter design pattern (Object Adapter with std::shared_ptr)"
    },
    "GOF_Bridge": {
        "prefix": "gof_bridge",
        "body": [
            "class ${2:Implementor} { public: virtual ~${2:Implementor}() = default; virtual void operationImp() = 0; };",
            "class ${4:ConcreteImplementorA} : public ${2:Implementor} { public: void operationImp() override { /* Impl A */ } };",
            "class ${5:ConcreteImplementorB} : public ${2:Implementor} { public: void operationImp() override { /* Impl B */ } };",
            "class ${1:Abstraction} {",
            "public:",
            "    ${1:Abstraction}(std::unique_ptr<${2:Implementor}> implementor) : implementor_(std::move(implementor)) {}",
            "    virtual ~${1:Abstraction}() = default;",
            "    virtual void operation() { if(implementor_) implementor_->operationImp(); }",
            "protected: std::unique_ptr<${2:Implementor}> implementor_;",
            "};",
            "class ${3:RefinedAbstraction} : public ${1:Abstraction} {",
            "public:",
            "    ${3:RefinedAbstraction}(std::unique_ptr<${2:Implementor}> implementor) : ${1:Abstraction}(std::move(implementor)) {}",
            "    void operation() override { /* Refined logic then call */ ${1:Abstraction::operation}(); /* More logic */ }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// #include <string>",
            "// // Implementor: Drawing API",
            "// class DrawingAPI { public: virtual ~DrawingAPI() = default; virtual void drawCircle(double x, double y, double radius) = 0; };",
            "// // Concrete Implementors: Specific drawing APIs",
            "// class DrawingAPI1 : public DrawingAPI { public: void drawCircle(double x, double y, double radius) override { std::cout << \"API1.drawCircle at (\" << x << \",\" << y << \") radius \" << radius << std::endl; } };",
            "// class DrawingAPI2 : public DrawingAPI { public: void drawCircle(double x, double y, double radius) override { std::cout << \"API2.drawCircle at (\" << x << \",\" << y << \") radius \" << radius << std::endl; } };",
            "// // Abstraction: Shape",
            "// class Shape {",
            "// protected: std::unique_ptr<DrawingAPI> drawingAPI_;",
            "// public: Shape(std::unique_ptr<DrawingAPI> api) : drawingAPI_(std::move(api)) {} virtual ~Shape() = default; virtual void draw() = 0; virtual void resizeByPercentage(double pct) = 0;",
            "// };",
            "// // Refined Abstraction: CircleShape",
            "// class CircleShape : public Shape {",
            "// private: double x_, y_, radius_;",
            "// public: CircleShape(double x, double y, double r, std::unique_ptr<DrawingAPI> api) : Shape(std::move(api)), x_(x), y_(y), radius_(r) {} ",
            "//         void draw() override { if(drawingAPI_) drawingAPI_->drawCircle(x_, y_, radius_); } ",
            "//         void resizeByPercentage(double pct) override { radius_ *= (1.0 + pct/100.0); }",
            "// };",
            "// int main() {",
            "//    auto api1 = std::make_unique<DrawingAPI1>();",
            "//    CircleShape circle1(1, 2, 3, std::move(api1));",
            "//    circle1.draw();",
            "//    circle1.resizeByPercentage(50);",
            "//    circle1.draw();",
            "//",
            "//    auto api2 = std::make_unique<DrawingAPI2>();",
            "//    CircleShape circle2(5, 6, 7, std::move(api2));",
            "//    circle2.draw();",
            "//    return 0;",
            "// }"
        ],
        "description": "Bridge design pattern"
    },
    "GOF_Composite": {
        "prefix": "gof_composite",
        "body": [
            "class ${1:Component} {",
            "public:",
            "    virtual ~${1:Component}() = default;",
            "    virtual void operation() = 0;",
            "    virtual void add(std::unique_ptr<${1:Component}> /*component*/) {} ",
            "    virtual void remove(${1:Component}* /*component*/) {} ",
            "    virtual bool isComposite() const { return false; }",
            "};",
            "class ${2:Leaf} : public ${1:Component} { public: void operation() override { /* Leaf operation */ } };",
            "class ${3:Composite} : public ${1:Component} {",
            "public:",
            "    void operation() override { for (const auto& child : children_) child->operation(); }",
            "    void add(std::unique_ptr<${1:Component}> component) override { children_.push_back(std::move(component)); }",
            "    void remove(${1:Component}* component) override { children_.erase(std::remove_if(children_.begin(), children_.end(), [&](const std::unique_ptr<${1:Component}>& p){ return p.get() == component; }), children_.end()); }",
            "    bool isComposite() const override { return true; }",
            "private: std::vector<std::unique_ptr<${1:Component}>> children_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <vector>",
            "// #include <memory>",
            "// #include <string>",
            "// #include <algorithm> // For std::remove_if",
            "// // Component: Graphic",
            "// class Graphic { public: virtual ~Graphic() = default; virtual void draw() const = 0; virtual void add(std::unique_ptr<Graphic> g) {} virtual std::string getName() const = 0; };",
            "// // Leaf: Simple graphic objects",
            "// class Line : public Graphic { private: std::string name_; public: Line(std::string name) : name_(std::move(name)) {} void draw() const override { std::cout << \"Drawing Line: \" << name_ << std::endl; } std::string getName() const override { return name_; } };",
            "// class Circle : public Graphic { private: std::string name_; public: Circle(std::string name) : name_(std::move(name)) {} void draw() const override { std::cout << \"Drawing Circle: \" << name_ << std::endl; } std::string getName() const override { return name_; } };",
            "// // Composite: Picture (can contain other graphics)",
            "// class Picture : public Graphic {",
            "// private: std::vector<std::unique_ptr<Graphic>> children_; std::string name_;",
            "// public: Picture(std::string name) : name_(std::move(name)) {} ",
            "//         void draw() const override { std::cout << \"Drawing Picture: \" << name_ << \" containing:\\n\"; for(const auto& child : children_) child->draw(); } ",
            "//         void add(std::unique_ptr<Graphic> g) override { children_.push_back(std::move(g)); } std::string getName() const override { return name_; }",
            "// };",
            "// int main() {",
            "//    auto pic1 = std::make_unique<Picture>(\"Main Picture\");",
            "//    pic1->add(std::make_unique<Line>(\"Line1\"));",
            "//    pic1->add(std::make_unique<Circle>(\"Circle1\"));",
            "//    auto subPic = std::make_unique<Picture>(\"Sub Picture\");",
            "//    subPic->add(std::make_unique<Line>(\"Line2\"));",
            "//    subPic->add(std::make_unique<Circle>(\"Circle2\"));",
            "//    pic1->add(std::move(subPic));",
            "//    pic1->draw();",
            "//    return 0;",
            "// }"
        ],
        "description": "Composite design pattern"
    },
    "GOF_Decorator": {
        "prefix": "gof_decorator",
        "body": [
            "class ${1:Component} { public: virtual ~${1:Component}() = default; virtual void operation() = 0; };",
            "class ${2:ConcreteComponent} : public ${1:Component} { public: void operation() override { /* Base Operation */ } };",
            "class ${3:Decorator} : public ${1:Component} {",
            "public:",
            "    ${3:Decorator}(std::unique_ptr<${1:Component}> component) : component_(std::move(component)) {}",
            "    void operation() override { if (component_) component_->operation(); }",
            "protected: std::unique_ptr<${1:Component}> component_;",
            "};",
            "class ${4:ConcreteDecoratorA} : public ${3:Decorator} {",
            "public:",
            "    ${4:ConcreteDecoratorA}(std::unique_ptr<${1:Component}> component) : ${3:Decorator}(std::move(component)) {}",
            "    void operation() override { ${3:Decorator::operation}(); /* Added Behavior A */ }",
            "};",
            "class ${5:ConcreteDecoratorB} : public ${3:Decorator} {",
            "public:",
            "    ${5:ConcreteDecoratorB}(std::unique_ptr<${1:Component}> component) : ${3:Decorator}(std::move(component)) {}",
            "    void operation() override { /* Added Behavior B before */ ${3:Decorator::operation}(); /* Added Behavior B after */ }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// // Component: Coffee",
            "// class Coffee { public: virtual ~Coffee() = default; virtual std::string getDescription() const = 0; virtual double cost() const = 0; };",
            "// // Concrete Component: Simple Coffee",
            "// class SimpleCoffee : public Coffee { public: std::string getDescription() const override { return \"Simple Coffee\"; } double cost() const override { return 1.0; } };",
            "// // Decorator: CoffeeDecorator",
            "// class CoffeeDecorator : public Coffee {",
            "// protected: std::unique_ptr<Coffee> decoratedCoffee_;",
            "// public: CoffeeDecorator(std::unique_ptr<Coffee> coffee) : decoratedCoffee_(std::move(coffee)) {} ",
            "//         std::string getDescription() const override { return decoratedCoffee_ ? decoratedCoffee_->getDescription() : \"\"; } ",
            "//         double cost() const override { return decoratedCoffee_ ? decoratedCoffee_->cost() : 0.0; }",
            "// };",
            "// // Concrete Decorators: Milk, Sugar",
            "// class MilkDecorator : public CoffeeDecorator { public: MilkDecorator(std::unique_ptr<Coffee> coffee) : CoffeeDecorator(std::move(coffee)) {} std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", Milk\"; } double cost() const override { return CoffeeDecorator::cost() + 0.5; } };",
            "// class SugarDecorator : public CoffeeDecorator { public: SugarDecorator(std::unique_ptr<Coffee> coffee) : CoffeeDecorator(std::move(coffee)) {} std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", Sugar\"; } double cost() const override { return CoffeeDecorator::cost() + 0.2; } };",
            "// int main() {",
            "//    std::unique_ptr<Coffee> myCoffee = std::make_unique<SimpleCoffee>();",
            "//    std::cout << myCoffee->getDescription() << \" Cost: $\" << myCoffee->cost() << std::endl;",
            "//    myCoffee = std::make_unique<MilkDecorator>(std::move(myCoffee));",
            "//    std::cout << myCoffee->getDescription() << \" Cost: $\" << myCoffee->cost() << std::endl;",
            "//    myCoffee = std::make_unique<SugarDecorator>(std::move(myCoffee));",
            "//    std::cout << myCoffee->getDescription() << \" Cost: $\" << myCoffee->cost() << std::endl;",
            "//    // Direct chaining",
            "//    std::unique_ptr<Coffee> anotherCoffee = std::make_unique<SugarDecorator>(std::make_unique<MilkDecorator>(std::make_unique<SimpleCoffee>()));",
            "//    std::cout << anotherCoffee->getDescription() << \" Cost: $\" << anotherCoffee->cost() << std::endl;",
            "//    return 0;",
            "// }"
        ],
        "description": "Decorator design pattern"
    },
    "GOF_Facade": {
        "prefix": "gof_facade",
        "body": [
            "class ${1:SubsystemA} { public: void operationA() { /* Subsystem A logic */ } };",
            "class ${2:SubsystemB} { public: void operationB() { /* Subsystem B logic */ } };",
            "class ${3:SubsystemC} { public: void operationC() { /* Subsystem C logic */ } };",
            "class ${4:Facade} {",
            "public:",
            "    void simplifiedOperation() { subsystemA_.operationA(); subsystemB_.operationB(); subsystemC_.operationC(); }",
            "private:",
            "    ${1:SubsystemA} subsystemA_; ${2:SubsystemB} subsystemB_; ${3:SubsystemC} subsystemC_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// // Subsystem components for a computer",
            "// class CPU { public: void freeze() { std::cout << \"CPU: Freezing...\\n\"; } void jump(long position) { std::cout << \"CPU: Jumping to \" << position << std::endl; } void execute() { std::cout << \"CPU: Executing...\\n\"; } };",
            "// class Memory { public: void load(long position, const std::string& data) { std::cout << \"Memory: Loading data '\" << data << \"' to position \" << position << std::endl; } };",
            "// class HardDrive { public: std::string read(long lba, int size) { std::cout << \"HardDrive: Reading \" << size << \" bytes from LBA \" << lba << std::endl; return \"some_data\"; } };",
            "// // Facade for starting the computer",
            "// class ComputerFacade {",
            "// private: CPU processor_; Memory ram_; HardDrive hd_;",
            "// public: void start() { std::cout << \"--- Starting Computer ---\\n\"; processor_.freeze(); ram_.load(0, hd_.read(0, 1024)); processor_.jump(0); processor_.execute(); std::cout << \"--- Computer Started ---\\n\"; }",
            "// };",
            "// int main() {",
            "//    ComputerFacade computer;",
            "//    computer.start();",
            "//    return 0;",
            "// }"
        ],
        "description": "Facade design pattern"
    },
    "GOF_Flyweight": {
        "prefix": "gof_flyweight",
        "body": [
            "class ${1:Flyweight} { public: virtual ~${1:Flyweight}() = default; virtual void operation(const std::string& extrinsicState) = 0; };",
            "class ${2:ConcreteFlyweight} : public ${1:Flyweight} {",
            "public: ${2:ConcreteFlyweight}(std::string intrinsicState) : intrinsicState_(std::move(intrinsicState)) {}",
            "        void operation(const std::string& extrinsicState) override { /* Use intrinsicState_ and extrinsicState */ }",
            "private: std::string intrinsicState_;",
            "};",
            "class ${3:FlyweightFactory} {",
            "public:",
            "    [[nodiscard]] std::shared_ptr<${1:Flyweight}> getFlyweight(const std::string& key) {",
            "        if (flyweights_.find(key) == flyweights_.end()) {",
            "            flyweights_[key] = std::make_shared<${2:ConcreteFlyweight}>(key);",
            "        }",
            "        return flyweights_[key];",
            "    }",
            "private: std::map<std::string, std::shared_ptr<${1:Flyweight}>> flyweights_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <vector>",
            "// #include <map>",
            "// #include <memory>",
            "// // Flyweight: Character properties (intrinsic state)",
            "// class CharacterStyle {",
            "// public: virtual ~CharacterStyle() = default; virtual void display(char character) = 0; // Extrinsic state: the character itself",
            "// protected: std::string font_; int size_; std::string color_;",
            "// public: CharacterStyle(std::string font, int size, std::string color) : font_(std::move(font)), size_(size), color_(std::move(color)) {} ",
            "// };",
            "// // Concrete Flyweight",
            "// class ConcreteCharacterStyle : public CharacterStyle {",
            "// public: ConcreteCharacterStyle(const std::string& font, int size, const std::string& color) : CharacterStyle(font, size, color) { std::cout << \"Creating style: \" << font << \", \" << size << \", \" << color << std::endl; }",
            "//         void display(char character) override { std::cout << \"Char '\" << character << \"' (Font: \" << font_ << \", Size: \" << size_ << \", Color: \" << color_ << \")\\n\"; }",
            "// };",
            "// // Flyweight Factory",
            "// class CharacterStyleFactory {",
            "// private: std::map<std::string, std::shared_ptr<CharacterStyle>> styles_;",
            "// public: [[nodiscard]] std::shared_ptr<CharacterStyle> getStyle(const std::string& font, int size, const std::string& color) { std::string key = font + std::to_string(size) + color; if (styles_.find(key) == styles_.end()) { styles_[key] = std::make_shared<ConcreteCharacterStyle>(font, size, color); } return styles_[key]; }",
            "// };",
            "// int main() {",
            "//    CharacterStyleFactory factory;",
            "//    std::vector<std::pair<char, std::shared_ptr<CharacterStyle>>> documentContent;",
            "//    documentContent.emplace_back('H', factory.getStyle(\"Arial\", 12, \"Black\"));",
            "//    documentContent.emplace_back('e', factory.getStyle(\"Arial\", 12, \"Black\"));",
            "//    documentContent.emplace_back('l', factory.getStyle(\"Arial\", 12, \"Black\"));",
            "//    documentContent.emplace_back('l', factory.getStyle(\"Arial\", 12, \"Black\"));",
            "//    documentContent.emplace_back('o', factory.getStyle(\"Times New Roman\", 14, \"Red\"));",
            "//    for (const auto& item : documentContent) { item.second->display(item.first); }",
            "//    return 0;",
            "// }"
        ],
        "description": "Flyweight design pattern"
    },
    "GOF_Proxy": {
        "prefix": "gof_proxy",
        "body": [
            "class ${1:Subject} { public: virtual ~${1:Subject}() = default; virtual void request() = 0; };",
            "class ${2:RealSubject} : public ${1:Subject} { public: void request() override { /* Handle request */ } };",
            "class ${3:Proxy} : public ${1:Subject} {",
            "public:",
            "    void request() override { if (!realSubject_) realSubject_ = std::make_unique<${2:RealSubject}>(); realSubject_->request(); /* Add proxy logic here */ }",
            "private: std::unique_ptr<${2:RealSubject}> realSubject_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// // Subject: Image interface",
            "// class Image { public: virtual ~Image() = default; virtual void display() = 0; };",
            "// // RealSubject: Loads image from disk (expensive)",
            "// class RealImage : public Image {",
            "// private: std::string filename_;",
            "// public: RealImage(const std::string& fname) : filename_(fname) { std::cout << \"Loading image: \" << filename_ << std::endl; /* Simulate disk load */ } ",
            "//         void display() override { std::cout << \"Displaying image: \" << filename_ << std::endl; }",
            "// };",
            "// // Proxy: Controls access to RealImage (lazy loading)",
            "// class ImageProxy : public Image {",
            "// private: std::unique_ptr<RealImage> realImage_; std::string filename_;",
            "// public: ImageProxy(const std::string& fname) : filename_(fname) {} ",
            "//         void display() override { if (!realImage_) { realImage_ = std::make_unique<RealImage>(filename_); } realImage_->display(); }",
            "// };",
            "// int main() {",
            "//    std::unique_ptr<Image> image1 = std::make_unique<ImageProxy>(\"photo1.jpg\");",
            "//    std::unique_ptr<Image> image2 = std::make_unique<ImageProxy>(\"photo2.png\");",
            "//    std::cout << \"Proxy created, image not loaded yet.\\n\";",
            "//    image1->display(); // Loads and displays photo1.jpg",
            "//    image1->display(); // Displays photo1.jpg (already loaded)",
            "//    image2->display(); // Loads and displays photo2.png",
            "//    return 0;",
            "// }"
        ],
        "description": "Proxy design pattern (Virtual Proxy)"
    },
    "GOF_ChainOfResponsibility": {
        "prefix": "gof_chain_of_responsibility",
        "body": [
            "class ${1:Handler} {",
            "public:",
            "    virtual ~${1:Handler}() = default;",
            "    void setNext(std::shared_ptr<${1:Handler}> next) { nextHandler_ = next; }",
            "    virtual void handleRequest(int request) { if (nextHandler_) nextHandler_->handleRequest(request); }",
            "protected: std::shared_ptr<${1:Handler}> nextHandler_;",
            "};",
            "class ${2:ConcreteHandlerA} : public ${1:Handler} {",
            "public: void handleRequest(int request) override { if (request < 10) { /* Handle A */ } else { ${1:Handler}::handleRequest(request); } }",
            "};",
            "class ${3:ConcreteHandlerB} : public ${1:Handler} {",
            "public: void handleRequest(int request) override { if (request >= 10 && request < 20) { /* Handle B */ } else { ${1:Handler}::handleRequest(request); } }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// #include <string>",
            "// // Request structure",
            "// struct Request { int id; std::string type; std::string data; };",
            "// // Handler interface",
            "// class RequestHandler {",
            "// protected: std::shared_ptr<RequestHandler> nextHandler_ = nullptr;",
            "// public: virtual ~RequestHandler() = default; void setNext(std::shared_ptr<RequestHandler> next) { nextHandler_ = next; }",
            "//         virtual void processRequest(const Request& req) { if(nextHandler_) nextHandler_->processRequest(req); else { std::cout << \"Request \" << req.id << \" unhandled.\\n\"; } }",
            "// };",
            "// // Concrete Handlers",
            "// class AuthenticationHandler : public RequestHandler {",
            "// public: void processRequest(const Request& req) override { if (req.type == \"AUTH\") { std::cout << \"AuthHandler: Authenticating request \" << req.id << \" with data: \" << req.data << std::endl; /* Auth logic */ } else { RequestHandler::processRequest(req); } }",
            "// };",
            "// class LoggingHandler : public RequestHandler {",
            "// public: void processRequest(const Request& req) override { std::cout << \"LogHandler: Logging request \" << req.id << \" of type \" << req.type << std::endl; /* Log logic */ RequestHandler::processRequest(req); /* Log after or pass then log */ }",
            "// };",
            "// class DataProcessingHandler : public RequestHandler {",
            "// public: void processRequest(const Request& req) override { if (req.type == \"DATA\") { std::cout << \"DataHandler: Processing data for request \" << req.id << \": \" << req.data << std::endl; /* Data processing */ } else { RequestHandler::processRequest(req); } }",
            "// };",
            "// int main() {",
            "//    auto authHandler = std::make_shared<AuthenticationHandler>();",
            "//    auto logHandler = std::make_shared<LoggingHandler>();",
            "//    auto dataHandler = std::make_shared<DataProcessingHandler>();",
            "//    // Build the chain: Log -> Auth -> Data",
            "//    logHandler->setNext(authHandler);",
            "//    authHandler->setNext(dataHandler);",
            "//    // Create some requests",
            "//    Request req1 = {1, \"AUTH\", \"user:pass\"};",
            "//    Request req2 = {2, \"DATA\", \"<xml>data</xml>\"};",
            "//    Request req3 = {3, \"OTHER\", \"misc_info\"};",
            "//    // Process requests starting from the head of the chain",
            "//    logHandler->processRequest(req1); std::cout << \"---\\n\";",
            "//    logHandler->processRequest(req2); std::cout << \"---\\n\";",
            "//    logHandler->processRequest(req3); std::cout << \"---\\n\";",
            "//    return 0;",
            "// }"
        ],
        "description": "Chain of Responsibility design pattern"
    },
    "GOF_Command": {
        "prefix": "gof_command",
        "body": [
            "class ${3:Receiver} { public: void action() { /* Receiver's action */ } };",
            "class ${1:Command} { public: virtual ~${1:Command}() = default; virtual void execute() = 0; };",
            "class ${2:ConcreteCommand} : public ${1:Command} {",
            "public: ${2:ConcreteCommand}(${3:Receiver}* receiver) : receiver_(receiver) {}",
            "        void execute() override { if(receiver_) receiver_->action(); }",
            "private: ${3:Receiver}* receiver_; /* Receiver is not owned by Command typically */",
            "};",
            "class ${4:Invoker} {",
            "public: void setCommand(std::unique_ptr<${1:Command}> command) { command_ = std::move(command); }",
            "        void executeCommand() { if(command_) command_->execute(); }",
            "private: std::unique_ptr<${1:Command}> command_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// #include <vector>",
            "// // Receiver: A Light",
            "// class Light { public: void turnOn() { std::cout << \"Light is ON\\n\"; } void turnOff() { std::cout << \"Light is OFF\\n\"; } };",
            "// // Command interface",
            "// class Command { public: virtual ~Command() = default; virtual void execute() = 0; };",
            "// // Concrete Commands",
            "// class LightOnCommand : public Command { private: Light* light_; public: LightOnCommand(Light* light) : light_(light) {} void execute() override { if(light_) light_->turnOn(); } };",
            "// class LightOffCommand : public Command { private: Light* light_; public: LightOffCommand(Light* light) : light_(light) {} void execute() override { if(light_) light_->turnOff(); } };",
            "// // Invoker: A Remote Control",
            "// class RemoteControl { private: std::unique_ptr<Command> slot_; public: void setCommand(std::unique_ptr<Command> cmd) { slot_ = std::move(cmd); } void pressButton() { if(slot_) slot_->execute(); } };",
            "// int main() {",
            "//    Light livingRoomLight;",
            "//    RemoteControl remote;",
            "//    remote.setCommand(std::make_unique<LightOnCommand>(&livingRoomLight));",
            "//    remote.pressButton(); // Light is ON",
            "//    remote.setCommand(std::make_unique<LightOffCommand>(&livingRoomLight));",
            "//    remote.pressButton(); // Light is OFF",
            "//    return 0;",
            "// }"
        ],
        "description": "Command design pattern"
    },
    "GOF_Interpreter": {
        "prefix": "gof_interpreter",
        "body": [
            "class ${1:AbstractExpression} { public: virtual ~${1:AbstractExpression}() = default; virtual int interpret(const std::map<std::string, int>& context) = 0; };",
            "class ${2:NumberExpression} : public ${1:AbstractExpression} {",
            "public: ${2:NumberExpression}(int number) : number_(number) {} int interpret(const std::map<std::string, int>&) override { return number_; }",
            "private: int number_;",
            "};",
            "class ${3:VariableExpression} : public ${1:AbstractExpression} {",
            "public: ${3:VariableExpression}(std::string varName) : varName_(std::move(varName)) {} int interpret(const std::map<std::string, int>& context) override { return context.at(varName_); }",
            "private: std::string varName_;",
            "};",
            "class ${4:AddExpression} : public ${1:AbstractExpression} {",
            "public:",
            "    ${4:AddExpression}(std::unique_ptr<${1:AbstractExpression}> left, std::unique_ptr<${1:AbstractExpression}> right) : left_(std::move(left)), right_(std::move(right)) {}",
            "    int interpret(const std::map<std::string, int>& context) override { return left_->interpret(context) + right_->interpret(context); }",
            "private: std::unique_ptr<${1:AbstractExpression}> left_; std::unique_ptr<${1:AbstractExpression}> right_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <map>",
            "// #include <memory>",
            "// // AbstractExpression (as defined above)",
            "// // NumberExpression (as defined above)",
            "// // VariableExpression (as defined above)",
            "// // AddExpression (as defined above)",
            "// // (For a real example, you'd also want Subtract, Multiply, etc.)",
            "// int main() {",
            "//    // Expression: (w + x) + 10",
            "//    // Where w=5, x=7",
            "//    auto w_var = std::make_unique<VariableExpression>(\"w\");",
            "//    auto x_var = std::make_unique<VariableExpression>(\"x\");",
            "//    auto sum_w_x = std::make_unique<AddExpression>(std::move(w_var), std::move(x_var));",
            "//    auto const_10 = std::make_unique<NumberExpression>(10);",
            "//    auto final_expr = std::make_unique<AddExpression>(std::move(sum_w_x), std::move(const_10));",
            "//    std::map<std::string, int> context = {{\"w\", 5}, {\"x\", 7}};",
            "//    int result = final_expr->interpret(context);",
            "//    std::cout << \"Result of (w + x) + 10 for w=5, x=7 is: \" << result << std::endl; // Should be 22",
            "//    return 0;",
            "// }"
        ],
        "description": "Interpreter design pattern"
    },
    "GOF_Iterator": {
        "prefix": "gof_iterator",
        "body": [
            "template<typename T, typename C>",
            "class ${1:Iterator} { public: virtual ~${1:Iterator}() = default; virtual void first() = 0; virtual void next() = 0; virtual bool isDone() const = 0; virtual T currentItem() const = 0; };",
            "template<typename T>",
            "class ${2:ConcreteIterator} : public ${1:Iterator}<T, ${2:ConcreteIterator}<T>> {",
            "public:",
            "    ${2:ConcreteIterator}(const std::vector<T>& collection) : collection_(collection), position_(0) {}",
            "    void first() override { position_ = 0; }",
            "    void next() override { position_++; }",
            "    bool isDone() const override { return position_ >= collection_.size(); }",
            "    T currentItem() const override { if(isDone()) throw std::out_of_range(\"Iterator out of bounds\"); return collection_[position_]; }",
            "private: const std::vector<T>& collection_; size_t position_;",
            "};",
            "template<typename T>",
            "class ${3:Aggregate} { public: virtual ~${3:Aggregate}() = default; [[nodiscard]] virtual std::unique_ptr<${1:Iterator}<T, ${2:ConcreteIterator}<T>>> createIterator() = 0; };",
            "template<typename T>",
            "class ${4:ConcreteAggregate} : public ${3:Aggregate}<T> {",
            "public:",
            "    ${4:ConcreteAggregate}(std::vector<T> data) : data_(std::move(data)) {}",
            "    void addItem(const T& item) { data_.push_back(item); }",
            "    [[nodiscard]] std::unique_ptr<${1:Iterator}<T, ${2:ConcreteIterator}<T>>> createIterator() override { return std::make_unique<${2:ConcreteIterator}<T>>(data_); }",
            "private: std::vector<T> data_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <vector>",
            "// #include <string>",
            "// #include <memory>",
            "// #include <stdexcept> // For std::out_of_range",
            "// // Iterator, ConcreteIterator, Aggregate, ConcreteAggregate (template versions as defined above)",
            "// int main() {",
            "//    ConcreteAggregate<std::string> stringCollection({\"Hello\", \"World\", \"Iterator\", \"Pattern\"});",
            "//    stringCollection.addItem(\"C++\");",
            "//    auto it = stringCollection.createIterator();",
            "//    for (it->first(); !it->isDone(); it->next()) {",
            "//        std::cout << it->currentItem() << std::endl;",
            "//    }",
            "//    ConcreteAggregate<int> intCollection({1, 2, 3, 4, 5});",
            "//    auto int_it = intCollection.createIterator();",
            "//    for (int_it->first(); !int_it->isDone(); int_it->next()) {",
            "//        std::cout << int_it->currentItem() << std::endl;",
            "//    }",
            "//    return 0;",
            "// }"
        ],
        "description": "Iterator design pattern (Templated)"
    },
    "GOF_Mediator": {
        "prefix": "gof_mediator",
        "body": [
            "class ${2:Colleague}; /* Forward Declaration */",
            "class ${1:Mediator} { public: virtual ~${1:Mediator}() = default; virtual void notify(${2:Colleague}* sender, const std::string& event) = 0; };",
            "class ${2:Colleague} { protected: ${1:Mediator}* mediator_; public: ${2:Colleague}(${1:Mediator}* mediator) : mediator_(mediator) {} virtual ~${2:Colleague}() = default; };",
            "class ${3:ConcreteColleagueA} : public ${2:Colleague} {",
            "public: ${3:ConcreteColleagueA}(${1:Mediator}* m) : ${2:Colleague}(m) {} void send(const std::string& msg) { mediator_->notify(this, \"A_sends:\" + msg); } void receive(const std::string& msg) { /* A receives: msg */ }",
            "};",
            "class ${4:ConcreteColleagueB} : public ${2:Colleague} {",
            "public: ${4:ConcreteColleagueB}(${1:Mediator}* m) : ${2:Colleague}(m) {} void send(const std::string& msg) { mediator_->notify(this, \"B_sends:\" + msg); } void receive(const std::string& msg) { /* B receives: msg */ }",
            "};",
            "class ${5:ConcreteMediator} : public ${1:Mediator} {",
            "public:",
            "    void setColleagues(${3:ConcreteColleagueA}* cA, ${4:ConcreteColleagueB}* cB) { colleagueA_ = cA; colleagueB_ = cB; }",
            "    void notify(${2:Colleague}* sender, const std::string& event) override { if (sender == colleagueA_) colleagueB_->receive(event); else if (sender == colleagueB_) colleagueA_->receive(event); }",
            "private: ${3:ConcreteColleagueA}* colleagueA_ = nullptr; ${4:ConcreteColleagueB}* colleagueB_ = nullptr;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <memory>",
            "// // Forward declare Mediator for Colleague",
            "// class ChatMediator;",
            "// // Colleague: User in a chat room",
            "// class User {",
            "// protected: ChatMediator* mediator_; std::string name_;",
            "// public: User(ChatMediator* mediator, std::string name) : mediator_(mediator), name_(std::move(name)) {} virtual ~User() = default; std::string getName() const { return name_; } virtual void send(const std::string& message) = 0; virtual void receive(const std::string& message, const std::string& fromUser) = 0;",
            "// };",
            "// // Mediator: ChatRoom interface",
            "// class ChatMediator { public: virtual ~ChatMediator() = default; virtual void sendMessage(const std::string& message, User* sender) = 0; virtual void addUser(User* user) = 0; };",
            "// // ConcreteColleague: ConcreteUser",
            "// class ConcreteUser : public User {",
            "// public: ConcreteUser(ChatMediator* mediator, const std::string& name) : User(mediator, name) {} ",
            "//         void send(const std::string& message) override { std::cout << name_ << \" sends: \" << message << std::endl; if(mediator_) mediator_->sendMessage(message, this); } ",
            "//         void receive(const std::string& message, const std::string& fromUser) override { std::cout << name_ << \" received from \" << fromUser << \": \" << message << std::endl; }",
            "// };",
            "// // ConcreteMediator: ChatRoomImplementation",
            "// class ChatRoom : public ChatMediator {",
            "// private: std::vector<User*> users_;",
            "// public: void addUser(User* user) override { users_.push_back(user); } ",
            "//         void sendMessage(const std::string& message, User* sender) override { for (User* user : users_) { if (user != sender) { user->receive(message, sender->getName()); } } }",
            "// };",
            "// int main() {",
            "//    ChatRoom chatRoomMediator;",
            "//    ConcreteUser user1(&chatRoomMediator, \"Alice\");",
            "//    ConcreteUser user2(&chatRoomMediator, \"Bob\");",
            "//    ConcreteUser user3(&chatRoomMediator, \"Charlie\");",
            "//    chatRoomMediator.addUser(&user1);",
            "//    chatRoomMediator.addUser(&user2);",
            "//    chatRoomMediator.addUser(&user3);",
            "//    user1.send(\"Hello everyone!\");",
            "//    user2.send(\"Hi Alice!\");",
            "//    return 0;",
            "// }"
        ],
        "description": "Mediator design pattern"
    },
    "GOF_Memento": {
        "prefix": "gof_memento",
        "body": [
            "class ${1:Memento} {",
            "public: ${1:Memento}(std::string state) : state_(std::move(state)) {} [[nodiscard]] std::string getState() const { return state_; }",
            "private: std::string state_; /* Could be more complex */",
            "};",
            "class ${2:Originator} {",
            "public:",
            "    void setState(const std::string& state) { state_ = state; }",
            "    [[nodiscard]] std::string getState() const { return state_; }",
            "    [[nodiscard]] std::unique_ptr<${1:Memento}> saveToMemento() { return std::make_unique<${1:Memento}>(state_); }",
            "    void restoreFromMemento(const ${1:Memento}* memento) { if(memento) state_ = memento->getState(); }",
            "private: std::string state_;",
            "};",
            "class ${3:Caretaker} {",
            "public:",
            "    void addMemento(std::unique_ptr<${1:Memento}> memento) { mementos_.push_back(std::move(memento)); }",
            "    [[nodiscard]] const ${1:Memento}* getMemento(size_t index) { if (index < mementos_.size()) return mementos_[index].get(); return nullptr; }",
            "private: std::vector<std::unique_ptr<${1:Memento}>> mementos_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// #include <vector>",
            "// #include <memory>",
            "// // Memento, Originator, Caretaker (as defined above)",
            "// int main() {",
            "//    Originator originator;",
            "//    Caretaker caretaker;",
            "//    originator.setState(\"State #1 - Initial\");",
            "//    caretaker.addMemento(originator.saveToMemento());",
            "//    std::cout << \"Current state: \" << originator.getState() << std::endl;",
            "//    originator.setState(\"State #2 - Modified\");",
            "//    caretaker.addMemento(originator.saveToMemento());",
            "//    std::cout << \"Current state: \" << originator.getState() << std::endl;",
            "//    originator.setState(\"State #3 - Further Modified\");",
            "//    std::cout << \"Current state: \" << originator.getState() << std::endl;",
            "//    // Restore to previous state (State #2)",
            "//    const Memento* mementoToRestore = caretaker.getMemento(1);",
            "//    if (mementoToRestore) { originator.restoreFromMemento(mementoToRestore); }",
            "//    std::cout << \"Restored state: \" << originator.getState() << std::endl;",
            "//    // Restore to initial state (State #1)",
            "//    mementoToRestore = caretaker.getMemento(0);",
            "//    if (mementoToRestore) { originator.restoreFromMemento(mementoToRestore); }",
            "//    std::cout << \"Restored state: \" << originator.getState() << std::endl;",
            "//    return 0;",
            "// }"
        ],
        "description": "Memento design pattern"
    },
    "GOF_State": {
        "prefix": "gof_state",
        "body": [
            "class ${2:Context}; /* Forward Declaration */",
            "class ${1:State} { public: virtual ~${1:State}() = default; virtual void handle(${2:Context}* context) = 0; };",
            "class ${3:ConcreteStateA} : public ${1:State} { public: void handle(${2:Context}* context) override; /* Transition logic in .cpp */ };",
            "class ${4:ConcreteStateB} : public ${1:State} { public: void handle(${2:Context}* context) override; /* Transition logic in .cpp */ };",
            "class ${2:Context} {",
            "public:",
            "    ${2:Context}(std::unique_ptr<${1:State}> initialState) : state_(std::move(initialState)) {} ",
            "    void setState(std::unique_ptr<${1:State}> state) { state_ = std::move(state); }",
            "    void request() { if(state_) state_->handle(this); }",
            "private: std::unique_ptr<${1:State}> state_;",
            "};",
            "// In .cpp for ConcreteStateA and ConcreteStateB to handle transitions:",
            "// void ${3:ConcreteStateA}::handle(${2:Context}* context) { /* Handle A's logic */ context->setState(std::make_unique<${4:ConcreteStateB}>()); }",
            "// void ${4:ConcreteStateB}::handle(${2:Context}* context) { /* Handle B's logic */ context->setState(std::make_unique<${3:ConcreteStateA}>()); }",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <memory>",
            "// #include <string>",
            "// // Forward declaration for Context in State classes",
            "// class TCPConnection;",
            "// // State interface for TCP connection",
            "// class TCPState { public: virtual ~TCPState() = default; virtual void open(TCPConnection* conn) = 0; virtual void close(TCPConnection* conn) = 0; virtual void acknowledge(TCPConnection* conn) = 0; virtual std::string getName() const = 0; };",
            "// // Forward declaration for States in Context",
            "// class TCPClosedState; class TCPOpenState; class TCPListenState;",
            "// // Context: TCPConnection",
            "// class TCPConnection {",
            "// private: std::unique_ptr<TCPState> state_;",
            "// public: TCPConnection(); // Defined after states",
            "//         void setState(std::unique_ptr<TCPState> newState) { state_ = std::move(newState); std::cout << \"Connection state changed to: \" << state_->getName() << std::endl; }",
            "//         void open() { if(state_) state_->open(this); }",
            "//         void close() { if(state_) state_->close(this); }",
            "//         void acknowledge() { if(state_) state_->acknowledge(this); }",
            "// };",
            "// // Concrete States",
            "// class TCPClosedState : public TCPState {",
            "// public: void open(TCPConnection* conn) override { std::cout << \"Closed: Opening connection...\\n\"; conn->setState(std::make_unique<TCPListenState>()); }",
            "//         void close(TCPConnection* conn) override { std::cout << \"Closed: Already closed.\\n\"; }",
            "//         void acknowledge(TCPConnection* conn) override { std::cout << \"Closed: Cannot acknowledge.\\n\"; }",
            "//         std::string getName() const override { return \"CLOSED\"; }",
            "// };",
            "// class TCPOpenState : public TCPState {",
            "// public: void open(TCPConnection* conn) override { std::cout << \"Open: Already open.\\n\"; }",
            "//         void close(TCPConnection* conn) override { std::cout << \"Open: Closing connection...\\n\"; conn->setState(std::make_unique<TCPClosedState>()); }",
            "//         void acknowledge(TCPConnection* conn) override { std::cout << \"Open: Acknowledging data...\\n\"; }",
            "//         std::string getName() const override { return \"OPEN\"; }",
            "// };",
            "// class TCPListenState : public TCPState {",
            "// public: void open(TCPConnection* conn) override { std::cout << \"Listen: Connection established.\\n\"; conn->setState(std::make_unique<TCPOpenState>()); }",
            "//         void close(TCPConnection* conn) override { std::cout << \"Listen: Closing listener...\\n\"; conn->setState(std::make_unique<TCPClosedState>()); }",
            "//         void acknowledge(TCPConnection* conn) override { std::cout << \"Listen: Cannot acknowledge in listen state.\\n\"; }",
            "//         std::string getName() const override { return \"LISTEN\"; }",
            "// };",
            "// TCPConnection::TCPConnection() { state_ = std::make_unique<TCPClosedState>(); std::cout << \"Connection initialized in state: \" << state_->getName() << std::endl; }",
            "// int main() {",
            "//    TCPConnection connection;",
            "//    connection.open();        // Closed -> Listen",
            "//    connection.open();        // Listen -> Open",
            "//    connection.acknowledge(); // Open: Acknowledges",
            "//    connection.close();       // Open -> Closed",
            "//    connection.acknowledge(); // Closed: Cannot acknowledge",
            "//    return 0;",
            "// }"
        ],
        "description": "State design pattern"
    },
    "GOF_Strategy": {
        "prefix": "gof_strategy",
        "body": [
            "class ${1:Strategy} { public: virtual ~${1:Strategy}() = default; virtual void executeAlgorithm() = 0; };",
            "class ${2:ConcreteStrategyA} : public ${1:Strategy} { public: void executeAlgorithm() override { /* Algorithm A */ } };",
            "class ${3:ConcreteStrategyB} : public ${1:Strategy} { public: void executeAlgorithm() override { /* Algorithm B */ } };",
            "class ${4:Context} {",
            "public:",
            "    void setStrategy(std::unique_ptr<${1:Strategy}> strategy) { strategy_ = std::move(strategy); }",
            "    void execute() { if(strategy_) strategy_->executeAlgorithm(); }",
            "private: std::unique_ptr<${1:Strategy}> strategy_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <vector>",
            "// #include <memory>",
            "// #include <algorithm> // For std::sort, std::reverse",
            "// #include <string>",
            "// // Strategy interface for sorting",
            "// class SortStrategy { public: virtual ~SortStrategy() = default; virtual void sort(std::vector<int>& data) = 0; };",
            "// // Concrete Strategies",
            "// class AscendingSort : public SortStrategy { public: void sort(std::vector<int>& data) override { std::sort(data.begin(), data.end()); std::cout << \"Sorted in Ascending order.\\n\"; } };",
            "// class DescendingSort : public SortStrategy { public: void sort(std::vector<int>& data) override { std::sort(data.begin(), data.end(), std::greater<int>()); std::cout << \"Sorted in Descending order.\\n\"; } };",
            "// // Context that uses a SortStrategy",
            "// class NumberList {",
            "// private: std::vector<int> numbers_; std::unique_ptr<SortStrategy> strategy_;",
            "// public: NumberList(std::vector<int> nums) : numbers_(std::move(nums)) {} ",
            "//         void setSortStrategy(std::unique_ptr<SortStrategy> strat) { strategy_ = std::move(strat); } ",
            "//         void sortList() { if(strategy_) strategy_->sort(numbers_); } ",
            "//         void printList() const { for(int num : numbers_) { std::cout << num << \" \"; } std::cout << std::endl; }",
            "// };",
            "// int main() {",
            "//    NumberList myList({5, 1, 9, 3, 7});",
            "//    myList.printList();",
            "//    myList.setSortStrategy(std::make_unique<AscendingSort>());",
            "//    myList.sortList();",
            "//    myList.printList();",
            "//    myList.setSortStrategy(std::make_unique<DescendingSort>());",
            "//    myList.sortList();",
            "//    myList.printList();",
            "//    return 0;",
            "// }"
        ],
        "description": "Strategy design pattern"
    },
    "GOF_TemplateMethod": {
        "prefix": "gof_template_method",
        "body": [
            "class ${1:AbstractClass} {",
            "public:",
            "    virtual ~${1:AbstractClass}() = default;",
            "    void templateMethod() final { primitiveOperation1(); primitiveOperation2(); concreteOperation(); hook(); }",
            "protected:",
            "    virtual void primitiveOperation1() = 0;",
            "    virtual void primitiveOperation2() = 0;",
            "    void concreteOperation() { /* Default concrete operation */ }",
            "    virtual void hook() {} /* Hook, subclasses can override */",
            "};",
            "class ${2:ConcreteClassA} : public ${1:AbstractClass} {",
            "protected:",
            "    void primitiveOperation1() override { /* Impl 1A */ }",
            "    void primitiveOperation2() override { /* Impl 2A */ }",
            "};",
            "class ${3:ConcreteClassB} : public ${1:AbstractClass} {",
            "protected:",
            "    void primitiveOperation1() override { /* Impl 1B */ }",
            "    void primitiveOperation2() override { /* Impl 2B */ }",
            "    void hook() override { /* Overridden hook B */ }",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <string>",
            "// // Abstract class for a document processor",
            "// class DocumentProcessor {",
            "// public: virtual ~DocumentProcessor() = default;",
            "//         // Template method defines the skeleton of document processing",
            "//         void processDocument() final { openFile(); parseContent(); processData(); saveFile(); closeFile(); hookAfterProcessing(); }",
            "// protected:",
            "//         virtual void openFile() { std::cout << \"DocumentProcessor: Opening file...\\n\"; }",
            "//         virtual void parseContent() = 0; // To be implemented by subclasses",
            "//         virtual void processData() { std::cout << \"DocumentProcessor: Processing common data...\\n\"; } // Common step",
            "//         virtual void saveFile() = 0;     // To be implemented by subclasses",
            "//         virtual void closeFile() { std::cout << \"DocumentProcessor: Closing file...\\n\"; }",
            "//         virtual void hookAfterProcessing() {} // Optional hook",
            "// };",
            "// // Concrete class for text documents",
            "// class TextDocumentProcessor : public DocumentProcessor {",
            "// protected:",
            "//     void parseContent() override { std::cout << \"TextDoc: Parsing text content.\\n\"; }",
            "//     void saveFile() override { std::cout << \"TextDoc: Saving as .txt file.\\n\"; }",
            "//     void hookAfterProcessing() override { std::cout << \"TextDoc: Performing text-specific cleanup.\\n\"; }",
            "// };",
            "// // Concrete class for CSV documents",
            "// class CsvDocumentProcessor : public DocumentProcessor {",
            "// protected:",
            "//     void parseContent() override { std::cout << \"CsvDoc: Parsing CSV content (comma-separated values).\\n\"; }",
            "//     void saveFile() override { std::cout << \"CsvDoc: Saving as .csv file.\\n\"; }",
            "//     // Uses default hook",
            "// };",
            "// int main() {",
            "//    std::cout << \"--- Processing Text Document ---\\n\";",
            "//    TextDocumentProcessor textProc;",
            "//    textProc.processDocument();",
            "//    std::cout << \"\\n--- Processing CSV Document ---\\n\";",
            "//    CsvDocumentProcessor csvProc;",
            "//    csvProc.processDocument();",
            "//    return 0;",
            "// }"
        ],
        "description": "Template Method design pattern"
    },
    "GOF_Visitor": {
        "prefix": "gof_visitor",
        "body": [
            "class ${2:ConcreteElementA}; /* Fwd Decls for Visitor */",
            "class ${3:ConcreteElementB};",
            "class ${1:Visitor} {",
            "public: virtual ~${1:Visitor}() = default; virtual void visit(${2:ConcreteElementA}* element) = 0; virtual void visit(${3:ConcreteElementB}* element) = 0;",
            "};",
            "class ${5:Element} { public: virtual ~${5:Element}() = default; virtual void accept(${1:Visitor}* visitor) = 0; };",
            "class ${2:ConcreteElementA} : public ${5:Element} { public: void accept(${1:Visitor}* visitor) override { visitor->visit(this); } void operationA() { /* Op A */ } };",
            "class ${3:ConcreteElementB} : public ${5:Element} { public: void accept(${1:Visitor}* visitor) override { visitor->visit(this); } void operationB() { /* Op B */ } };",
            "class ${4:ConcreteVisitor} : public ${1:Visitor} {",
            "public:",
            "    void visit(${2:ConcreteElementA}* element) override { element->operationA(); /* Visitor logic for A */ }",
            "    void visit(${3:ConcreteElementB}* element) override { element->operationB(); /* Visitor logic for B */ }",
            "};",
            "class ${6:ObjectStructure} {",
            "public:",
            "    void attach(std::unique_ptr<${5:Element}> element) { elements_.push_back(std::move(element)); }",
            "    void acceptAll(${1:Visitor}* visitor) { for(const auto& elem : elements_) elem->accept(visitor); }",
            "private: std::vector<std::unique_ptr<${5:Element}>> elements_;",
            "};",
            "",
            "// Example usage:",
            "// #include <iostream>",
            "// #include <vector>",
            "// #include <memory>",
            "// #include <string>",
            "// // Forward declare elements for Visitor",
            "// class BookItem; class ElectronicsItem;",
            "// // Visitor interface: ShoppingCartVisitor",
            "// class ShoppingCartVisitor { public: virtual ~ShoppingCartVisitor() = default; virtual void visit(BookItem* book) = 0; virtual void visit(ElectronicsItem* electronic) = 0; };",
            "// // Element interface: Product",
            "// class Product { public: virtual ~Product() = default; virtual void accept(ShoppingCartVisitor* visitor) = 0; virtual double getPrice() const = 0; virtual std::string getName() const = 0; };",
            "// // Concrete Elements",
            "// class BookItem : public Product { private: double price_; std::string title_; public: BookItem(std::string title, double price) : title_(std::move(title)), price_(price) {} void accept(ShoppingCartVisitor* visitor) override { visitor->visit(this); } double getPrice() const override { return price_; } std::string getName() const override { return title_; } /* Book specific methods */ };",
            "// class ElectronicsItem : public Product { private: double price_; std::string model_; public: ElectronicsItem(std::string model, double price) : model_(std::move(model)), price_(price) {} void accept(ShoppingCartVisitor* visitor) override { visitor->visit(this); } double getPrice() const override { return price_; } std::string getName() const override { return model_; } /* Electronics specific methods */ };",
            "// // Concrete Visitor: PriceCalculatorVisitor",
            "// class PriceCalculatorVisitor : public ShoppingCartVisitor { private: double total_ = 0.0; public: void visit(BookItem* book) override { total_ += book->getPrice(); std::cout << \"Book: \" << book->getName() << \" Price: \" << book->getPrice() << std::endl; } void visit(ElectronicsItem* electronic) override { total_ += electronic->getPrice() * 1.05; /* Add 5% tax for electronics */ std::cout << \"Electronics: \" << electronic->getName() << \" Price (incl. tax): \" << electronic->getPrice() * 1.05 << std::endl;} double getTotalPrice() const { return total_; } };",
            "// // ObjectStructure: ShoppingCart",
            "// class ShoppingCart { private: std::vector<std::unique_ptr<Product>> items_; public: void addItem(std::unique_ptr<Product> item) { items_.push_back(std::move(item)); } void calculatePrices(ShoppingCartVisitor* visitor) { for(const auto& item : items_) { item->accept(visitor); } } };",
            "// int main() {",
            "//    ShoppingCart cart;",
            "//    cart.addItem(std::make_unique<BookItem>(\"Design Patterns\", 50.0));",
            "//    cart.addItem(std::make_unique<ElectronicsItem>(\"Laptop\", 1200.0));",
            "//    cart.addItem(std::make_unique<BookItem>(\"Effective C++\", 40.0));",
            "//    PriceCalculatorVisitor priceCalc;",
            "//    cart.calculatePrices(&priceCalc);",
            "//    std::cout << \"Total cart price: \" << priceCalc.getTotalPrice() << std::endl;",
            "//    return 0;",
            "// }"
        ],
        "description": "Visitor design pattern"
    },
    "5 Constructors (Move/Copy/Destructor)": {
        "prefix": "task_5constructors",
        "body": [
            "${1:ClassName}() = default;  // Default constructor",
            "~${1:ClassName}() = default; // Destructor",
            "${1:ClassName}(const ${1:ClassName}& other) = default; // Copy constructor",
            "${1:ClassName}& operator=(const ${1:ClassName}& other) = default; // Copy assignment",
            "${1:ClassName}(${1:ClassName}&& other) noexcept = default; // Move constructor",
            "${1:ClassName}& operator=(${1:ClassName}&& other) noexcept = default; // Move assignment"
        ],
        "description": "Generate default, copy, move constructors/assignment operators, and destructor."
    },
    "std::unique_ptr": {
        "prefix": "task_u",
        "body": [
            "std::unique_ptr<${1:Type}>"
        ],
        "description": "std::unique_ptr<Type>"
    },
    "std::shared_ptr": {
        "prefix": "task_s",
        "body": [
            "std::shared_ptr<${1:Type}>"
        ],
        "description": "std::shared_ptr<Type>"
    },
    "std::vector<double>": {
        "prefix": "task_r",
        "body": [
            "std::vector<double>"
        ],
        "description": "std::vector<double>"
    },
    "std::vector<int>": {
        "prefix": "task_i",
        "body": [
            "std::vector<int>"
        ],
        "description": "std::vector<int>"
    },
    "std::vector<std::string>": {
        "prefix": "task_str",
        "body": [
            "std::vector<std::string>"
        ],
        "description": "std::vector<std::string>"
    },
    "Function: Generate Random Doubles Vector": {
        "prefix": "task_func_rnd_vec_double",
        "body": [
            "// Requires: <vector>, <random>, <algorithm> (for std::generate)",
            "[[nodiscard]] std::vector<double> generateRandomDoubles(size_t count, double min_val = 0.0, double max_val = 1.0) {",
            "    std::vector<double> vec(count);",
            "    if (count == 0) return vec;",
            "    std::random_device rd;",
            "    std::mt19937 gen(rd());",
            "    std::uniform_real_distribution<double> dis(min_val, max_val);",
            "    std::generate(vec.begin(), vec.end(), [&]() { return dis(gen); });",
            "    return vec;",
            "}"
        ],
        "description": "Defines a function that returns a std::vector<double> with random numbers."
    },
    "Function: Generate Random Integers Vector": {
        "prefix": "task_func_rnd_vec_int",
        "body": [
            "// Requires: <vector>, <random>, <algorithm> (for std::generate)",
            "[[nodiscard]] std::vector<int> generateRandomInts(size_t count, int min_val = 0, int max_val = 100) {",
            "    std::vector<int> vec(count);",
            "    if (count == 0) return vec;",
            "    std::random_device rd;",
            "    std::mt19937 gen(rd());",
            "    std::uniform_int_distribution<int> dis(min_val, max_val);",
            "    std::generate(vec.begin(), vec.end(), [&]() { return dis(gen); });",
            "    return vec;",
            "}"
        ],
        "description": "Defines a function that returns a std::vector<int> with random numbers."
    },
    "Function: Generate Random Strings Vector": {
        "prefix": "task_func_rnd_vec_str",
        "body": [
            "// Requires: <vector>, <string>, <random>, <algorithm> (for std::generate)",
            "[[nodiscard]] std::vector<std::string> generateRandomStrings(size_t count, int min_len = 1, int max_len = 10) {",
            "    std::vector<std::string> vec(count);",
            "    if (count == 0) return vec;",
            "    std::random_device rd;",
            "    std::mt19937 gen(rd());",
            "    std::uniform_int_distribution<int> len_dis(min_len, std::max(min_len, max_len));",
            "    std::uniform_int_distribution<int> char_dis('a', 'z');",
            "    std::generate(vec.begin(), vec.end(), [&]() {",
            "        int length = len_dis(gen);",
            "        std::string str_val;",
            "        str_val.reserve(length);",
            "        for (int i = 0; i < length; ++i) {",
            "            str_val += static_cast<char>(char_dis(gen));",
            "        }",
            "        return str_val;",
            "    });",
            "    return vec;",
            "}"
        ],
        "description": "Defines a function that returns a std::vector<std::string> with random strings."
    },
    "Function: Measure Execution Time": {
        "prefix": "task_func_measure_time",
        "body": [
            "// Requires: <chrono>, <functional>, <iostream>, <string>",
            "template<typename Func>",
            "void measureTime(const std::string& operationName, Func operation) {",
            "    auto start = std::chrono::high_resolution_clock::now();",
            "    operation();",
            "    auto end = std::chrono::high_resolution_clock::now();",
            "    std::chrono::duration<double, std::milli> duration = end - start;",
            "    std::cout << operationName << \" took: \" << duration.count() << \" ms\\n\";",
            "}",
            "// Usage: measureTime(\"My Operation\", [&]() { /* code to measure */ });"
        ],
        "description": "Defines a function template to measure and print execution time of a lambda."
    },
    "Function: Sleep Milliseconds": {
        "prefix": "task_func_sleep_ms",
        "body": [
            "// Requires: <chrono>, <thread>",
            "void sleepMilliseconds(int milliseconds) {",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));",
            "}",
            "// Usage: sleepMilliseconds(100);"
        ],
        "description": "Defines a function to sleep for a specified number of milliseconds."
    },
    "Function: Simple Logger": {
        "prefix": "task_func_logger",
        "body": [
            "// Requires: <iostream>, <string>, <chrono>, <iomanip> (for std::put_time), <ctime> (for std::time_t, std::tm, std::localtime)",
            "// Note on std::localtime: Not thread-safe on all platforms without _r or _s versions.",
            "// For cross-platform thread-safe time formatting, consider a library or more complex handling.",
            "void appLogger(const std::string& id, const std::string& type, const std::string& message) {",
            "    auto now_sys_clock = std::chrono::system_clock::now();",
            "    std::time_t now_time_t = std::chrono::system_clock::to_time_t(now_sys_clock);",
            "    std::tm time_info_buf;",
            "    // Platform-specific localtime_s or localtime_r for thread safety",
            "#if defined(_WIN32) || defined(_WIN64)",
            "    localtime_s(&time_info_buf, &now_time_t);",
            "#else",
            "    localtime_r(&now_time_t, &time_info_buf); // POSIX",
            "#endif",
            "    std::cout << \"[\" << id << \"] \"",
            "              << std::put_time(&time_info_buf, \"%Y-%m-%d %H:%M:%S\")",
            "              << \" [\" << type << \"]: \"",
            "              << message << std::endl;",
            "}",
            "// Usage: appLogger(\"ModuleX\", \"INFO\", \"Process started.\");"
        ],
        "description": "Defines a simple logger function (id, time, type, message)."
    }
}
