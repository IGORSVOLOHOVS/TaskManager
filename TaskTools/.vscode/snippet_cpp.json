{
    "GOF_Singleton": {
        "prefix": "gof_singleton",
        "body": [
            "class ${1:Singleton} {",
            "public:",
            "    static ${1:Singleton}& getInstance() {",
            "        static ${1:Singleton} instance;",
            "        return instance;",
            "    }",
            "    void doSomething() {",
            "        // Implementation",
            "    }",
            "private:",
            "    ${1:Singleton}() {}",
            "    ${1:Singleton}(const ${1:Singleton}&) = delete;",
            "    ${1:Singleton}& operator=(${1:Singleton}&) = delete;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${1:Singleton}& instance = ${1:Singleton}::getInstance();",
            "//    instance.doSomething();",
            "//    return 0;",
            "// }"
        ],
        "description": "Singleton design pattern"
    },
    "GOF_FactoryMethod": {
        "prefix": "gof_factory_method",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    virtual void use() = 0;",
            "    virtual ~${1:Product}() = default;",
            "};",
            "",
            "class ${2:ConcreteProductA} : public ${1:Product} {",
            "public:",
            "    void use() override {",
            "        // Implementation for ConcreteProductA",
            "    }",
            "};",
            "",
            "class ${3:ConcreteProductB} : public ${1:Product} {",
            "public:",
            "    void use() override {",
            "        // Implementation for ConcreteProductB",
            "    }",
            "};",
            "",
            "class ${4:Creator} {",
            "public:",
            "    virtual ${1:Product}* createProduct() = 0;",
            "    virtual ~${4:Creator}() = default;",
            "    void someOperation() {",
            "        ${1:Product}* product = createProduct();",
            "        product->use();",
            "        delete product;",
            "    }",
            "};",
            "",
            "class ${5:ConcreteCreatorA} : public ${4:Creator} {",
            "public:",
            "    ${1:Product}* createProduct() override {",
            "        return new ${2:ConcreteProductA}();",
            "    }",
            "};",
            "",
            "class ${6:ConcreteCreatorB} : public ${4:Creator} {",
            "public:",
            "    ${1:Product}* createProduct() override {",
            "        return new ${3:ConcreteProductB}();",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${4:Creator}* creatorA = new ${5:ConcreteCreatorA}();",
            "//    creatorA->someOperation(); // Uses ConcreteProductA",
            "//    delete creatorA;",
            "//    ${4:Creator}* creatorB = new ${6:ConcreteCreatorB}();",
            "//    creatorB->someOperation(); // Uses ConcreteProductB",
            "//    delete creatorB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Factory Method design pattern"
    },
    "GOF_AbstractFactory": {
        "prefix": "gof_abstract_factory",
        "body": [
            "// Abstract Products",
            "class ${1:AbstractProductA} {",
            "public:",
            "    virtual void useA() = 0;",
            "    virtual ~${1:AbstractProductA}() = default;",
            "};",
            "",
            "class ${2:AbstractProductB} {",
            "public:",
            "    virtual void useB() = 0;",
            "    virtual ~${2:AbstractProductB}() = default;",
            "};",
            "",
            "// Concrete Products",
            "class ${3:ConcreteProductA1} : public ${1:AbstractProductA} {",
            "public:",
            "    void useA() override {",
            "        // Implementation for ConcreteProductA1",
            "    }",
            "};",
            "",
            "class ${4:ConcreteProductA2} : public ${1:AbstractProductA} {",
            "public:",
            "    void useA() override {",
            "        // Implementation for ConcreteProductA2",
            "    }",
            "};",
            "",
            "class ${5:ConcreteProductB1} : public ${2:AbstractProductB} {",
            "public:",
            "    void useB() override {",
            "        // Implementation for ConcreteProductB1",
            "    }",
            "};",
            "",
            "class ${6:ConcreteProductB2} : public ${2:AbstractProductB} {",
            "public:",
            "    void useB() override {",
            "        // Implementation for ConcreteProductB2",
            "    }",
            "};",
            "",
            "// Abstract Factory",
            "class ${7:AbstractFactory} {",
            "public:",
            "    virtual ${1:AbstractProductA}* createProductA() = 0;",
            "    virtual ${2:AbstractProductB}* createProductB() = 0;",
            "    virtual ~${7:AbstractFactory}() = default;",
            "};",
            "",
            "// Concrete Factories",
            "class ${8:ConcreteFactory1} : public ${7:AbstractFactory} {",
            "public:",
            "    ${1:AbstractProductA}* createProductA() override {",
            "        return new ${3:ConcreteProductA1}();",
            "    }",
            "    ${2:AbstractProductB}* createProductB() override {",
            "        return new ${5:ConcreteProductB1}();",
            "    }",
            "};",
            "",
            "class ${9:ConcreteFactory2} : public ${7:AbstractFactory} {",
            "public:",
            "    ${1:AbstractProductA}* createProductA() override {",
            "        return new ${4:ConcreteProductA2}();",
            "    }",
            "    ${2:AbstractProductB}* createProductB() override {",
            "        return new ${6:ConcreteProductB2}();",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${7:AbstractFactory}* factory1 = new ${8:ConcreteFactory1}();",
            "//    ${1:AbstractProductA}* productA1 = factory1->createProductA();",
            "//    ${2:AbstractProductB}* productB1 = factory1->createProductB();",
            "//    productA1->useA();",
            "//    productB1->useB();",
            "//    delete factory1;",
            "//    delete productA1;",
            "//    delete productB1;",
            "//",
            "//    ${7:AbstractFactory}* factory2 = new ${9:ConcreteFactory2}();",
            "//    ${1:AbstractProductA}* productA2 = factory2->createProductA();",
            "//    ${2:AbstractProductB}* productB2 = factory2->createProductB();",
            "//    productA2->useA();",
            "//    productB2->useB();",
            "//    delete factory2;",
            "//    delete productA2;",
            "//    delete productB2;",
            "//    return 0;",
            "// }"
        ],
        "description": "Abstract Factory design pattern"
    },
    "GOF_Builder": {
        "prefix": "gof_builder",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    void setPartA(const std::string& partA) { partA_ = partA; }",
            "    void setPartB(const std::string& partB) { partB_ = partB; }",
            "    void listParts() const {",
            "        std::cout << \"Product parts: PartA = \" << partA_ << \", PartB = \" << partB_ << std::endl;",
            "    }",
            "private:",
            "    std::string partA_;",
            "    std::string partB_;",
            "};",
            "",
            "class ${2:Builder} {",
            "public:",
            "    virtual void buildPartA() = 0;",
            "    virtual void buildPartB() = 0;",
            "    virtual ${1:Product}* getProduct() = 0;",
            "    virtual ~${2:Builder}() = default;",
            "};",
            "",
            "class ${3:ConcreteBuilder} : public ${2:Builder} {",
            "public:",
            "    ${3:ConcreteBuilder}() : product_(new ${1:Product}()) {}",
            "    ~${3:ConcreteBuilder}() override { delete product_; }",
            "",
            "    void buildPartA() override {",
            "        product_->setPartA(\"PartA implementation\");",
            "    }",
            "    void buildPartB() override {",
            "        product_->setPartB(\"PartB implementation\");",
            "    }",
            "    ${1:Product}* getProduct() override {",
            "        ${1:Product}* result = product_;",
            "        product_ = new ${1:Product}(); // Reset for next product",
            "        return result;",
            "    }",
            "private:",
            "    ${1:Product}* product_;",
            "};",
            "",
            "class ${4:Director} {",
            "public:",
            "    void setBuilder(${2:Builder}* builder) {",
            "        builder_ = builder;",
            "    }",
            "    ${1:Product}* construct() {",
            "        builder_->buildPartA();",
            "        builder_->buildPartB();",
            "        return builder_->getProduct();",
            "    }",
            "private:",
            "    ${2:Builder}* builder_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${4:Director} director;",
            "//    ${3:ConcreteBuilder} builder;",
            "//    director.setBuilder(&builder);",
            "//",
            "//    ${1:Product}* product = director.construct();",
            "//    product->listParts();",
            "//    delete product;",
            "//    return 0;",
            "// }"
        ],
        "description": "Builder design pattern"
    },
    "GOF_Prototype": {
        "prefix": "gof_prototype",
        "body": [
            "class ${1:Prototype} {",
            "public:",
            "    virtual ${1:Prototype}* clone() const = 0;",
            "    virtual void operation() = 0;",
            "    virtual ~${1:Prototype}() = default;",
            "};",
            "",
            "class ${2:ConcretePrototypeA} : public ${1:Prototype} {",
            "public:",
            "    ${2:ConcretePrototypeA}(int value) : value_(value) {}",
            "    ${2:ConcretePrototypeA}* clone() const override {",
            "        return new ${2:ConcretePrototypeA}(*this);",
            "    }",
            "    void operation() override {",
            "        std::cout << \"ConcretePrototypeA operation with value: \" << value_ << std::endl;",
            "    }",
            "private:",
            "    int value_;",
            "};",
            "",
            "class ${3:ConcretePrototypeB} : public ${1:Prototype} {",
            "public:",
            "    ${3:ConcretePrototypeB}(std::string label) : label_(label) {}",
            "    ${3:ConcretePrototypeB}* clone() const override {",
            "        return new ${3:ConcretePrototypeB}(*this);",
            "    }",
            "    void operation() override {",
            "        std::cout << \"ConcretePrototypeB operation with label: \" << label_ << std::endl;",
            "    }",
            "private:",
            "    std::string label_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:ConcretePrototypeA}* protoA = new ${2:ConcretePrototypeA}(10);",
            "//    ${1:Prototype}* cloneA = protoA->clone();",
            "//    cloneA->operation(); // Output: ConcretePrototypeA operation with value: 10",
            "//    delete protoA;",
            "//    delete cloneA;",
            "//",
            "//    ${3:ConcretePrototypeB}* protoB = new ${3:ConcretePrototypeB}(\"Prototype B\");",
            "//    ${1:Prototype}* cloneB = protoB->clone();",
            "//    cloneB->operation(); // Output: ConcretePrototypeB operation with label: Prototype B",
            "//    delete protoB;",
            "//    delete cloneB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Prototype design pattern"
    },
    "GOF_Adapter": {
        "prefix": "gof_adapter",
        "body": [
            "// Target interface",
            "class ${1:Target} {",
            "public:",
            "    virtual void request() = 0;",
            "    virtual ~${1:Target}() = default;",
            "};",
            "",
            "// Adaptee class",
            "class ${2:Adaptee} {",
            "public:",
            "    void specificRequest() {",
            "        // Adaptee's specific behavior",
            "        std::cout << \"Adaptee's specific request.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Adapter class",
            "class ${3:Adapter} : public ${1:Target} {",
            "public:",
            "    ${3:Adapter}(${2:Adaptee}* adaptee) : adaptee_(adaptee) {}",
            "    void request() override {",
            "        // Convert Target's request to Adaptee's specific request",
            "        adaptee_->specificRequest();",
            "    }",
            "private:",
            "    ${2:Adaptee}* adaptee_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:Adaptee}* adaptee = new ${2:Adaptee}();",
            "//    ${1:Target}* target = new ${3:Adapter}(adaptee);",
            "//    target->request(); // Calls Adaptee's specificRequest through Adapter",
            "//    delete adaptee;",
            "//    delete target;",
            "//    return 0;",
            "// }"
        ],
        "description": "Adapter design pattern"
    },
    "GOF_Bridge": {
        "prefix": "gof_bridge",
        "body": [
            "// Abstraction",
            "class ${1:Abstraction} {",
            "public:",
            "    ${1:Abstraction}(class ${2:Implementor}* implementor) : implementor_(implementor) {}",
            "    virtual void operation() {",
            "        implementor_->operationImp();",
            "    }",
            "    virtual ~${1:Abstraction}() = default;",
            "protected:",
            "    ${2:Implementor}* implementor_;",
            "};",
            "",
            "// Refined Abstraction",
            "class ${3:RefinedAbstraction} : public ${1:Abstraction} {",
            "public:",
            "    ${3:RefinedAbstraction}(${2:Implementor}* implementor) : ${1:Abstraction}(implementor) {}",
            "    void operation() override {",
            "        // Extended operation",
            "        ${1:Abstraction::operation}();",
            "        std::cout << \"Refined Abstraction operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Implementor interface",
            "class ${2:Implementor} {",
            "public:",
            "    virtual void operationImp() = 0;",
            "    virtual ~${2:Implementor}() = default;",
            "};",
            "",
            "// Concrete Implementors",
            "class ${4:ConcreteImplementorA} : public ${2:Implementor} {",
            "public:",
            "    void operationImp() override {",
            "        std::cout << \"Concrete Implementor A operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "class ${5:ConcreteImplementorB} : public ${2:Implementor} {",
            "public:",
            "    void operationImp() override {",
            "        std::cout << \"Concrete Implementor B operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:Implementor}* implementorA = new ${4:ConcreteImplementorA}();",
            "//    ${1:Abstraction}* abstraction = new ${1:Abstraction}(implementorA);",
            "//    abstraction->operation(); // Uses ConcreteImplementorA",
            "//    delete implementorA;",
            "//    delete abstraction;",
            "//",
            "//    ${2:Implementor}* implementorB = new ${5:ConcreteImplementorB}();",
            "//    ${1:Abstraction}* refinedAbstraction = new ${3:RefinedAbstraction}(implementorB);",
            "//    refinedAbstraction->operation(); // Uses ConcreteImplementorB and Refined Abstraction",
            "//    delete implementorB;",
            "//    delete refinedAbstraction;",
            "//    return 0;",
            "// }"
        ],
        "description": "Bridge design pattern"
    },
    "GOF_Composite": {
        "prefix": "gof_composite",
        "body": [
            "#include <list>",
            "",
            "// Component interface",
            "class ${1:Component} {",
            "public:",
            "    virtual void operation() = 0;",
            "    virtual void add(${1:Component}* component) {}",
            "    virtual void remove(${1:Component}* component) {}",
            "    virtual ~${1:Component}() = default;",
            "};",
            "",
            "// Leaf class",
            "class ${2:Leaf} : public ${1:Component} {",
            "public:",
            "    void operation() override {",
            "        std::cout << \"Leaf operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Composite class",
            "class ${3:Composite} : public ${1:Component} {",
            "public:",
            "    void operation() override {",
            "        std::cout << \"Composite operation. Children operations:\\n\";",
            "        for (${1:Component}* component : children_) {",
            "            component->operation();",
            "        }",
            "    }",
            "    void add(${1:Component}* component) override {",
            "        children_.push_back(component);",
            "    }",
            "    void remove(${1:Component}* component) override {",
            "        children_.remove(component);",
            "    }",
            "private:",
            "    std::list<${1:Component}*> children_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${3:Composite}* composite = new ${3:Composite}();",
            "//    ${2:Leaf}* leaf1 = new ${2:Leaf}();",
            "//    ${2:Leaf}* leaf2 = new ${2:Leaf}();",
            "//    composite->add(leaf1);",
            "//    composite->add(leaf2);",
            "//    composite->operation(); // Calls operation on composite and its leaves",
            "//    delete composite;",
            "//    delete leaf1;",
            "//    delete leaf2;",
            "//    return 0;",
            "// }"
        ],
        "description": "Composite design pattern"
    },
    "GOF_Decorator": {
        "prefix": "gof_decorator",
        "body": [
            "// Component interface",
            "class ${1:Component} {",
            "public:",
            "    virtual void operation() = 0;",
            "    virtual ~${1:Component}() = default;",
            "};",
            "",
            "// Concrete Component",
            "class ${2:ConcreteComponent} : public ${1:Component} {",
            "public:",
            "    void operation() override {",
            "        std::cout << \"Concrete Component operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Decorator class",
            "class ${3:Decorator} : public ${1:Component} {",
            "public:",
            "    ${3:Decorator}(${1:Component}* component) : component_(component) {}",
            "    void operation() override {",
            "        if (component_) {",
            "            component_->operation();",
            "        }",
            "    }",
            "    virtual ~${3:Decorator}() = default;",
            "protected:",
            "    ${1:Component}* component_;",
            "};",
            "",
            "// Concrete Decorators",
            "class ${4:ConcreteDecoratorA} : public ${3:Decorator} {",
            "public:",
            "    ${4:ConcreteDecoratorA}(${1:Component}* component) : ${3:Decorator}(component) {}",
            "    void operation() override {",
            "        ${3:Decorator::operation}();",
            "        std::cout << \"Concrete Decorator A operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "class ${5:ConcreteDecoratorB} : public ${3:Decorator} {",
            "public:",
            "    ${5:ConcreteDecoratorB}(${1:Component}* component) : ${3:Decorator}(component) {}",
            "    void operation() override {",
            "        std::cout << \"Concrete Decorator B (before).\" << std::endl;",
            "        ${3:Decorator::operation}();",
            "        std::cout << \"Concrete Decorator B (after).\" << std::endl;",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${1:Component}* component = new ${2:ConcreteComponent}();",
            "//    ${1:Component}* decoratorA = new ${4:ConcreteDecoratorA}(component);",
            "//    ${1:Component}* decoratorB = new ${5:ConcreteDecoratorB}(decoratorA);",
            "//    decoratorB->operation(); // Calls operations from Component and Decorators A and B",
            "//    delete component;",
            "//    delete decoratorA;",
            "//    delete decoratorB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Decorator design pattern"
    },
    "GOF_Facade": {
        "prefix": "gof_facade",
        "body": [
            "// Subsystem classes",
            "class ${1:SubsystemA} {",
            "public:",
            "    void operationA() {",
            "        std::cout << \"Subsystem A operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "class ${2:SubsystemB} {",
            "public:",
            "    void operationB() {",
            "        std::cout << \"Subsystem B operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "class ${3:SubsystemC} {",
            "public:",
            "    void operationC() {",
            "        std::cout << \"Subsystem C operation.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Facade class",
            "class ${4:Facade} {",
            "public:",
            "    void operation() {",
            "        std::cout << \"Facade operation starts.\\n\";",
            "        subsystemA_.operationA();",
            "        subsystemB_.operationB();",
            "        subsystemC_.operationC();",
            "        std::cout << \"Facade operation finishes.\\n\";",
            "    }",
            "private:",
            "    ${1:SubsystemA} subsystemA_;",
            "    ${2:SubsystemB} subsystemB_;",
            "    ${3:SubsystemC} subsystemC_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${4:Facade} facade;",
            "//    facade.operation(); // Simplifies subsystem interaction through Facade",
            "//    return 0;",
            "// }"
        ],
        "description": "Facade design pattern"
    },
    "GOF_Flyweight": {
        "prefix": "gof_flyweight",
        "body": [
            "#include <map>",
            "",
            "// Flyweight interface",
            "class ${1:Flyweight} {",
            "public:",
            "    virtual void operation(const std::string& extrinsicState) = 0;",
            "    virtual ~${1:Flyweight}() = default;",
            "};",
            "",
            "// Concrete Flyweight",
            "class ${2:ConcreteFlyweight} : public ${1:Flyweight} {",
            "public:",
            "    ${2:ConcreteFlyweight}(const std::string& intrinsicState) : intrinsicState_(intrinsicState) {}",
            "    void operation(const std::string& extrinsicState) override {",
            "        std::cout << \"ConcreteFlyweight: Intrinsic state = \" << intrinsicState_ << \", Extrinsic state = \" << extrinsicState << std::endl;",
            "    }",
            "private:",
            "    std::string intrinsicState_;",
            "};",
            "",
            "// Flyweight Factory",
            "class ${3:FlyweightFactory} {",
            "public:",
            "    ${1:Flyweight}* getFlyweight(const std::string& key) {",
            "        if (flyweights_.find(key) == flyweights_.end()) {",
            "            flyweights_[key] = new ${2:ConcreteFlyweight}(key);",
            "        }",
            "        return flyweights_[key];",
            "    }",
            "private:",
            "    std::map<std::string, ${1:Flyweight}*> flyweights_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${3:FlyweightFactory} factory;",
            "//    ${1:Flyweight}* flyweight1 = factory.getFlyweight(\"state1\");",
            "//    flyweight1->operation(\"extrinsic1\");",
            "//    ${1:Flyweight}* flyweight2 = factory.getFlyweight(\"state1\"); // Returns existing flyweight",
            "//    flyweight2->operation(\"extrinsic2\");",
            "//    ${1:Flyweight}* flyweight3 = factory.getFlyweight(\"state2\");",
            "//    flyweight3->operation(\"extrinsic3\");",
            "//    return 0;",
            "// }"
        ],
        "description": "Flyweight design pattern"
    },
    "GOF_Proxy": {
        "prefix": "gof_proxy",
        "body": [
            "// Subject interface",
            "class ${1:Subject} {",
            "public:",
            "    virtual void request() = 0;",
            "    virtual ~${1:Subject}() = default;",
            "};",
            "",
            "// Real Subject",
            "class ${2:RealSubject} : public ${1:Subject} {",
            "public:",
            "    void request() override {",
            "        std::cout << \"Real Subject: Handling request.\" << std::endl;",
            "    }",
            "};",
            "",
            "// Proxy class",
            "class ${3:Proxy} : public ${1:Subject} {",
            "public:",
            "    ${3:Proxy}() : realSubject_(nullptr) {}",
            "    ~${3:Proxy}() override { delete realSubject_; }",
            "    void request() override {",
            "        // Lazy initialization or access control",
            "        if (!realSubject_) {",
            "            realSubject_ = new ${2:RealSubject}();",
            "        }",
            "        // Additional logic can be added here",
            "        std::cout << \"Proxy: Request forwarding to Real Subject.\\n\";",
            "        realSubject_->request();",
            "    }",
            "private:",
            "    ${2:RealSubject}* realSubject_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${1:Subject}* proxy = new ${3:Proxy}();",
            "//    proxy->request(); // Proxy controls access to RealSubject",
            "//    delete proxy;",
            "//    return 0;",
            "// }"
        ],
        "description": "Proxy design pattern"
    },
    "GOF_ChainOfResponsibility": {
        "prefix": "gof_chain_of_responsibility",
        "body": [
            "// Handler interface",
            "class ${1:Handler} {",
            "public:",
            "    virtual void setNext(${1:Handler}* nextHandler) {",
            "        nextHandler_ = nextHandler;",
            "    }",
            "    virtual void handleRequest(int request) {",
            "        if (nextHandler_) {",
            "            nextHandler_->handleRequest(request);",
            "        }",
            "    }",
            "    virtual ~${1:Handler}() = default;",
            "protected:",
            "    ${1:Handler}* nextHandler_ = nullptr;",
            "};",
            "",
            "// Concrete Handlers",
            "class ${2:ConcreteHandlerA} : public ${1:Handler} {",
            "public:",
            "    void handleRequest(int request) override {",
            "        if (request >= 0 && request < 10) {",
            "            std::cout << \"ConcreteHandlerA: Handling request \" << request << std::endl;",
            "        } else {",
            "            ${1:Handler::handleRequest}(request);",
            "        }",
            "    }",
            "};",
            "",
            "class ${3:ConcreteHandlerB} : public ${1:Handler} {",
            "public:",
            "    void handleRequest(int request) override {",
            "        if (request >= 10 && request < 20) {",
            "            std::cout << \"ConcreteHandlerB: Handling request \" << request << std::endl;",
            "        } else {",
            "            ${1:Handler::handleRequest}(request);",
            "        }",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:ConcreteHandlerA}* handlerA = new ${2:ConcreteHandlerA}();",
            "//    ${3:ConcreteHandlerB}* handlerB = new ${3:ConcreteHandlerB}();",
            "//    handlerA->setNext(handlerB); // Chain: handlerA -> handlerB",
            "//",
            "//    handlerA->handleRequest(5);  // Handled by ConcreteHandlerA",
            "//    handlerA->handleRequest(15); // Handled by ConcreteHandlerB",
            "//    handlerA->handleRequest(25); // Not handled, reaches end of chain",
            "//",
            "//    delete handlerA;",
            "//    delete handlerB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Chain of Responsibility design pattern"
    },
    "GOF_Command": {
        "prefix": "gof_command",
        "body": [
            "// Command interface",
            "class ${1:Command} {",
            "public:",
            "    virtual void execute() = 0;",
            "    virtual ~${1:Command}() = default;",
            "};",
            "",
            "// Concrete Command",
            "class ${2:ConcreteCommand} : public ${1:Command} {",
            "public:",
            "    ${2:ConcreteCommand}(class ${3:Receiver}* receiver) : receiver_(receiver) {}",
            "    void execute() override {",
            "        receiver_->action();",
            "    }",
            "private:",
            "    ${3:Receiver}* receiver_;",
            "};",
            "",
            "// Receiver class",
            "class ${3:Receiver} {",
            "public:",
            "    void action() {",
            "        std::cout << \"Receiver: Performing action.\\n\";",
            "    }",
            "};",
            "",
            "// Invoker class",
            "class ${4:Invoker} {",
            "public:",
            "    void setCommand(${1:Command}* command) {",
            "        command_ = command;",
            "    }",
            "    void executeCommand() {",
            "        command_->execute();",
            "    }",
            "private:",
            "    ${1:Command}* command_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${3:Receiver}* receiver = new ${3:Receiver}();",
            "//    ${1:Command}* command = new ${2:ConcreteCommand}(receiver);",
            "//    ${4:Invoker}* invoker = new ${4:Invoker}();",
            "//",
            "//    invoker->setCommand(command);",
            "//    invoker->executeCommand(); // Invoker executes the Command, which calls Receiver action",
            "//",
            "//    delete receiver;",
            "//    delete command;",
            "//    delete invoker;",
            "//    return 0;",
            "// }"
        ],
        "description": "Command design pattern"
    },
    "GOF_Interpreter": {
        "prefix": "gof_interpreter",
        "body": [
            "// Abstract Expression",
            "class ${1:AbstractExpression} {",
            "public:",
            "    virtual int interpret(const std::map<std::string, int>& context) = 0;",
            "    virtual ~${1:AbstractExpression}() = default;",
            "};",
            "",
            "// Terminal Expression (Number)",
            "class ${2:NumberExpression} : public ${1:AbstractExpression} {",
            "public:",
            "    ${2:NumberExpression}(int number) : number_(number) {}",
            "    int interpret(const std::map<std::string, int>& context) override {",
            "        return number_;",
            "    }",
            "private:",
            "    int number_;",
            "};",
            "",
            "// Terminal Expression (Variable)",
            "class ${3:VariableExpression} : public ${1:AbstractExpression} {",
            "public:",
            "    ${3:VariableExpression}(const std::string& variableName) : variableName_(variableName) {}",
            "    int interpret(const std::map<std::string, int>& context) override {",
            "        return context.at(variableName_);",
            "    }",
            "private:",
            "    std::string variableName_;",
            "};",
            "",
            "// Non-terminal Expression (Add)",
            "class ${4:AddExpression} : public ${1:AbstractExpression} {",
            "public:",
            "    ${4:AddExpression}(${1:AbstractExpression}* left, ${1:AbstractExpression}* right) : left_(left), right_(right) {}",
            "    ~${4:AddExpression}() override {",
            "        delete left_;",
            "        delete right_;",
            "    }",
            "    int interpret(const std::map<std::string, int>& context) override {",
            "        return left_->interpret(context) + right_->interpret(context);",
            "    }",
            "private:",
            "    ${1:AbstractExpression}* left_;",
            "    ${1:AbstractExpression}* right_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    // Expression: w + x",
            "//    ${1:AbstractExpression}* w = new ${3:VariableExpression}(\"w\");",
            "//    ${1:AbstractExpression}* x = new ${3:VariableExpression}(\"x\");",
            "//    ${1:AbstractExpression}* expression = new ${4:AddExpression}(w, x);",
            "//",
            "//    std::map<std::string, int> context = {{\"w\", 5}, {\"x\", 10}};",
            "//    int result = expression->interpret(context); // Evaluates to 15",
            "//    std::cout << \"Result: \" << result << std::endl;",
            "//",
            "//    delete expression;",
            "//    return 0;",
            "// }"
        ],
        "description": "Interpreter design pattern"
    },
    "GOF_Iterator": {
        "prefix": "gof_iterator",
        "body": [
            "#include <vector>",
            "",
            "// Abstract Iterator",
            "class ${1:Iterator} {",
            "public:",
            "    virtual void first() = 0;",
            "    virtual void next() = 0;",
            "    virtual bool isDone() = 0;",
            "    virtual int currentItem() = 0;",
            "    virtual ~${1:Iterator}() = default;",
            "};",
            "",
            "// Concrete Iterator",
            "class ${2:ConcreteIterator} : public ${1:Iterator} {",
            "public:",
            "    ${2:ConcreteIterator}(const std::vector<int>& collection) : collection_(collection), position_(0) {}",
            "    void first() override {",
            "        position_ = 0;",
            "    }",
            "    void next() override {",
            "        position_++;",
            "    }",
            "    bool isDone() override {",
            "        return position_ >= collection_.size();",
            "    }",
            "    int currentItem() override {",
            "        if (isDone()) {",
            "            return -1; // Or throw exception",
            "        }",
            "        return collection_[position_];",
            "    }",
            "private:",
            "    const std::vector<int>& collection_;",
            "    int position_;",
            "};",
            "",
            "// Aggregate Interface",
            "class ${3:Aggregate} {",
            "public:",
            "    virtual ${1:Iterator}* createIterator() = 0;",
            "    virtual ~${3:Aggregate}() = default;",
            "};",
            "",
            "// Concrete Aggregate",
            "class ${4:ConcreteAggregate} : public ${3:Aggregate} {",
            "public:",
            "    ${4:ConcreteAggregate(std::vector<int> data) : data_(data) {}",
            "    ${1:Iterator}* createIterator() override {",
            "        return new ${2:ConcreteIterator}(data_);",
            "    }",
            "private:",
            "    std::vector<int> data_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    std::vector<int> numbers = {1, 2, 3, 4, 5};",
            "//    ${3:Aggregate}* aggregate = new ${4:ConcreteAggregate}(numbers);",
            "//    ${1:Iterator}* iterator = aggregate->createIterator();",
            "//",
            "//    for (iterator->first(); !iterator->isDone(); iterator->next()) {",
            "//        std::cout << iterator->currentItem() << std::endl;",
            "//    }",
            "//",
            "//    delete iterator;",
            "//    delete aggregate;",
            "//    return 0;",
            "// }"
        ],
        "description": "Iterator design pattern"
    },
    "GOF_Mediator": {
        "prefix": "gof_mediator",
        "body": [
            "// Mediator interface",
            "class ${1:Mediator} {",
            "public:",
            "    virtual void notify(class ${2:Colleague}* colleague, const std::string& event) = 0;",
            "    virtual ~${1:Mediator}() = default;",
            "};",
            "",
            "// Colleague class",
            "class ${2:Colleague} {",
            "public:",
            "    ${2:Colleague}(${1:Mediator}* mediator) : mediator_(mediator) {}",
            "    virtual ~${2:Colleague}() = default;",
            "protected:",
            "    ${1:Mediator}* mediator_;",
            "};",
            "",
            "// Concrete Colleague A",
            "class ${3:ConcreteColleagueA} : public ${2:Colleague} {",
            "public:",
            "    ${3:ConcreteColleagueA}(${1:Mediator}* mediator) : ${2:Colleague}(mediator) {}",
            "    void send(const std::string& message) {",
            "        std::cout << \"ColleagueA sends: \" << message << std::endl;",
            "        mediator_->notify(this, message);",
            "    }",
            "    void receive(const std::string& message) {",
            "        std::cout << \"ColleagueA receives: \" << message << std::endl;",
            "    }",
            "};",
            "",
            "// Concrete Colleague B",
            "class ${4:ConcreteColleagueB} : public ${2:Colleague} {",
            "public:",
            "    ${4:ConcreteColleagueB}(${1:Mediator}* mediator) : ${2:Colleague}(mediator) {}",
            "    void send(const std::string& message) {",
            "        std::cout << \"ColleagueB sends: \" << message << std::endl;",
            "        mediator_->notify(this, message);",
            "    }",
            "    void receive(const std::string& message) {",
            "        std::cout << \"ColleagueB receives: \" << message << std::endl;",
            "    }",
            "};",
            "",
            "// Concrete Mediator",
            "class ${5:ConcreteMediator} : public ${1:Mediator} {",
            "public:",
            "    void setColleagueA(${3:ConcreteColleagueA}* colleagueA) {",
            "        colleagueA_ = colleagueA;",
            "    }",
            "    void setColleagueB(${4:ConcreteColleagueB}* colleagueB) {",
            "        colleagueB_ = colleagueB;",
            "    }",
            "    void notify(${2:Colleague}* sender, const std::string& event) override {",
            "        if (sender == colleagueA_) {",
            "            colleagueB_->receive(event);",
            "        } else if (sender == colleagueB_) {",
            "            colleagueA_->receive(event);",
            "        }",
            "    }",
            "private:",
            "    ${3:ConcreteColleagueA}* colleagueA_ = nullptr;",
            "    ${4:ConcreteColleagueB}* colleagueB_ = nullptr;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${5:ConcreteMediator}* mediator = new ${5:ConcreteMediator}();",
            "//    ${3:ConcreteColleagueA}* colleagueA = new ${3:ConcreteColleagueA}(mediator);",
            "//    ${4:ConcreteColleagueB}* colleagueB = new ${4:ConcreteColleagueB}(mediator);",
            "//",
            "//    mediator->setColleagueA(colleagueA);",
            "//    mediator->setColleagueB(colleagueB);",
            "//",
            "//    colleagueA->send(\"Hello from A\"); // A sends message, Mediator routes to B",
            "//    colleagueB->send(\"Hi from B\");    // B sends message, Mediator routes to A",
            "//",
            "//    delete mediator;",
            "//    delete colleagueA;",
            "//    delete colleagueB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Mediator design pattern"
    },
    "GOF_Memento": {
        "prefix": "gof_memento",
        "body": [
            "// Memento class",
            "class ${1:Memento} {",
            "public:",
            "    ${1:Memento}(const std::string& state) : state_(state) {}",
            "    std::string getState() const {",
            "        return state_;",
            "    }",
            "private:",
            "    std::string state_;",
            "};",
            "",
            "// Originator class",
            "class ${2:Originator} {",
            "public:",
            "    void setState(const std::string& state) {",
            "        state_ = state;",
            "        std::cout << \"Originator: State set to \" << state_ << std::endl;",
            "    }",
            "    ${1:Memento}* saveToMemento() {",
            "        std::cout << \"Originator: Saving to Memento.\\n\";",
            "        return new ${1:Memento}(state_);",
            "    }",
            "    void restoreFromMemento(${1:Memento}* memento) {",
            "        state_ = memento->getState();",
            "        std::cout << \"Originator: State after restoring from Memento: \" << state_ << std::endl;",
            "    }",
            "private:",
            "    std::string state_;",
            "};",
            "",
            "// Caretaker class",
            "class ${3:Caretaker} {",
            "public:",
            "    void addMemento(${1:Memento}* memento) {",
            "        mementos_.push_back(memento);",
            "    }",
            "    ${1:Memento}* getMemento(int index) {",
            "        if (index >= 0 && index < mementos_.size()) {",
            "            return mementos_[index];",
            "        }",
            "        return nullptr;",
            "    }",
            "private:",
            "    std::vector<${1:Memento}*> mementos_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:Originator}* originator = new ${2:Originator}();",
            "//    ${3:Caretaker}* caretaker = new ${3:Caretaker}();",
            "//",
            "//    originator->setState(\"State #1\");",
            "//    caretaker->addMemento(originator->saveToMemento());",
            "//    originator->setState(\"State #2\");",
            "//    caretaker->addMemento(originator->saveToMemento());",
            "//    originator->setState(\"State #3\");",
            "//",
            "//    originator->restoreFromMemento(caretaker->getMemento(1)); // Restores to State #2",
            "//",
            "//    delete originator;",
            "//    delete caretaker;",
            "//    return 0;",
            "// }"
        ],
        "description": "Memento design pattern"
    },
    "GOF_State": {
        "prefix": "gof_state",
        "body": [
            "// State interface",
            "class ${1:State} {",
            "public:",
            "    virtual void handle() = 0;",
            "    virtual ~${1:State}() = default;",
            "};",
            "",
            "// Context class",
            "class ${2:Context} {",
            "public:",
            "    void setState(${1:State}* state) {",
            "        state_ = state;",
            "    }",
            "    void request() {",
            "        state_->handle();",
            "    }",
            "private:",
            "    ${1:State}* state_;",
            "};",
            "",
            "// Concrete State A",
            "class ${3:ConcreteStateA} : public ${1:State} {",
            "public:",
            "    void handle() override {",
            "        std::cout << \"ConcreteStateA: Handling request.\\n\";",
            "    }",
            "};",
            "",
            "// Concrete State B",
            "class ${4:ConcreteStateB} : public ${1:State} {",
            "public:",
            "    void handle() override {",
            "        std::cout << \"ConcreteStateB: Handling request.\\n\";",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${2:Context}* context = new ${2:Context}();",
            "//    ${1:State}* stateA = new ${3:ConcreteStateA}();",
            "//    ${1:State}* stateB = new ${4:ConcreteStateB}();",
            "//",
            "//    context->setState(stateA);",
            "//    context->request(); // Context is in StateA",
            "//",
            "//    context->setState(stateB);",
            "//    context->request(); // Context is in StateB",
            "//",
            "//    delete context;",
            "//    delete stateA;",
            "//    delete stateB;",
            "//    return 0;",
            "// }"
        ],
        "description": "State design pattern"
    },
    "GOF_Strategy": {
        "prefix": "gof_strategy",
        "body": [
            "// Strategy interface",
            "class ${1:Strategy} {",
            "public:",
            "    virtual void execute() = 0;",
            "    virtual ~${1:Strategy}() = default;",
            "};",
            "",
            "// Concrete Strategy A",
            "class ${2:ConcreteStrategyA} : public ${1:Strategy} {",
            "public:",
            "    void execute() override {",
            "        std::cout << \"ConcreteStrategyA: Executing strategy A.\\n\";",
            "    }",
            "};",
            "",
            "// Concrete Strategy B",
            "class ${3:ConcreteStrategyB} : public ${1:Strategy} {",
            "public:",
            "    void execute() override {",
            "        std::cout << \"ConcreteStrategyB: Executing strategy B.\\n\";",
            "    }",
            "};",
            "",
            "// Context class",
            "class ${4:Context} {",
            "public:",
            "    void setStrategy(${1:Strategy}* strategy) {",
            "        strategy_ = strategy;",
            "    }",
            "    void contextInterface() {",
            "        strategy_->execute();",
            "    }",
            "private:",
            "    ${1:Strategy}* strategy_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${4:Context}* context = new ${4:Context}();",
            "//    ${1:Strategy}* strategyA = new ${2:ConcreteStrategyA}();",
            "//    ${1:Strategy}* strategyB = new ${3:ConcreteStrategyB}();",
            "//",
            "//    context->setStrategy(strategyA);",
            "//    context->contextInterface(); // Context uses StrategyA",
            "//",
            "//    context->setStrategy(strategyB);",
            "//    context->contextInterface(); // Context uses StrategyB",
            "//",
            "//    delete context;",
            "//    delete strategyA;",
            "//    delete strategyB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Strategy design pattern"
    },
    "GOF_TemplateMethod": {
        "prefix": "gof_template_method",
        "body": [
            "// Abstract Class",
            "class ${1:AbstractClass} {",
            "public:",
            "    // Template method",
            "    void templateMethod() {",
            "        primitiveOperation1();",
            "        primitiveOperation2();",
            "        concreteOperation(); // Concrete operation, same in subclasses",
            "        hook(); // Hook, subclasses may override",
            "    }",
            "    virtual ~${1:AbstractClass}() = default;",
            "protected:",
            "    virtual void primitiveOperation1() = 0;",
            "    virtual void primitiveOperation2() = 0;",
            "    // Concrete operation, subclasses can use but not override",
            "    void concreteOperation() {",
            "        std::cout << \"AbstractClass: Concrete Operation.\\n\";",
            "    }",
            "    // Hook operation, subclasses may override",
            "    virtual void hook() {}",
            "};",
            "",
            "// Concrete Class A",
            "class ${2:ConcreteClassA} : public ${1:AbstractClass} {",
            "protected:",
            "    void primitiveOperation1() override {",
            "        std::cout << \"ConcreteClassA: Primitive Operation 1.\\n\";",
            "    }",
            "    void primitiveOperation2() override {",
            "        std::cout << \"ConcreteClassA: Primitive Operation 2.\\n\";",
            "    }",
            "};",
            "",
            "// Concrete Class B",
            "class ${3:ConcreteClassB} : public ${1:AbstractClass} {",
            "protected:",
            "    void primitiveOperation1() override {",
            "        std::cout << \"ConcreteClassB: Primitive Operation 1.\\n\";",
            "    }",
            "    void primitiveOperation2() override {",
            "        std::cout << \"ConcreteClassB: Primitive Operation 2.\\n\";",
            "    }",
            "    void hook() override {",
            "        std::cout << \"ConcreteClassB: Hook overridden.\\n\";",
            "    }",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${1:AbstractClass}* classA = new ${2:ConcreteClassA}();",
            "//    classA->templateMethod(); // Calls template method with ConcreteClassA implementations",
            "//    std::cout << std::endl;",
            "//    ${1:AbstractClass}* classB = new ${3:ConcreteClassB}();",
            "//    classB->templateMethod(); // Calls template method with ConcreteClassB implementations and hook",
            "//",
            "//    delete classA;",
            "//    delete classB;",
            "//    return 0;",
            "// }"
        ],
        "description": "Template Method design pattern"
    },
    "GOF_Visitor": {
        "prefix": "gof_visitor",
        "body": [
            "// Visitor interface",
            "class ${1:Visitor} {",
            "public:",
            "    virtual void visitConcreteElementA(class ${2:ConcreteElementA}* element) = 0;",
            "    virtual void visitConcreteElementB(class ${3:ConcreteElementB}* element) = 0;",
            "    virtual ~${1:Visitor}() = default;",
            "};",
            "",
            "// Concrete Visitor",
            "class ${4:ConcreteVisitor} : public ${1:Visitor} {",
            "public:",
            "    void visitConcreteElementA(${2:ConcreteElementA}* element) override {",
            "        std::cout << \"ConcreteVisitor: Visiting ConcreteElementA.\\n\";",
            "        element->operationA(); // Visitor can call specific operations of ConcreteElementA",
            "    }",
            "    void visitConcreteElementB(${3:ConcreteElementB}* element) override {",
            "        std::cout << \"ConcreteVisitor: Visiting ConcreteElementB.\\n\";",
            "        element->operationB(); // Visitor can call specific operations of ConcreteElementB",
            "    }",
            "};",
            "",
            "// Element interface",
            "class ${5:Element} {",
            "public:",
            "    virtual void accept(${1:Visitor}* visitor) = 0;",
            "    virtual ~${5:Element}() = default;",
            "};",
            "",
            "// Concrete Element A",
            "class ${2:ConcreteElementA} : public ${5:Element} {",
            "public:",
            "    void accept(${1:Visitor}* visitor) override {",
            "        visitor->visitConcreteElementA(this);",
            "    }",
            "    void operationA() {",
            "        std::cout << \"ConcreteElementA: Operation A.\\n\";",
            "    }",
            "};",
            "",
            "// Concrete Element B",
            "class ${3:ConcreteElementB} : public ${5:Element} {",
            "public:",
            "    void accept(${1:Visitor}* visitor) override {",
            "        visitor->visitConcreteElementB(this);",
            "    }",
            "    void operationB() {",
            "        std::cout << \"ConcreteElementB: Operation B.\\n\";",
            "    }",
            "};",
            "",
            "// Object Structure",
            "class ${6:ObjectStructure} {",
            "public:",
            "    void attach(${5:Element}* element) {",
            "        elements_.push_back(element);",
            "    }",
            "    void detach(${5:Element}* element) {",
            "        // Implementation to remove element",
            "    }",
            "    void acceptVisitor(${1:Visitor}* visitor) {",
            "        for (auto element : elements_) {",
            "            element->accept(visitor);",
            "        }",
            "    }",
            "private:",
            "    std::vector<${5:Element}*> elements_;",
            "};",
            "",
            "// Example usage:",
            "// int main() {",
            "//    ${6:ObjectStructure}* objectStructure = new ${6:ObjectStructure}();",
            "//    ${5:Element}* elementA = new ${2:ConcreteElementA}();",
            "//    ${5:Element}* elementB = new ${3:ConcreteElementB}();",
            "//",
            "//    objectStructure->attach(elementA);",
            "//    objectStructure->attach(elementB);",
            "//",
            "//    ${1:Visitor}* visitor = new ${4:ConcreteVisitor}();",
            "//    objectStructure->acceptVisitor(visitor); // Visitor operates on all elements in structure",
            "//",
            "//    delete objectStructure;",
            "//    delete elementA;",
            "//    delete elementB;",
            "//    delete visitor;",
            "//    return 0;",
            "// }"
        ],
        "description": "Visitor design pattern"
    },
    "Include All STD": {
        "prefix": "task_std",
        "body": [
            "// Include all standard C++ libraries (for convenience, not always recommended for production)",
            "#include <iostream>",
            "#include <fstream>",
            "#include <sstream>",
            "#include <iomanip>",
            "#include <string>",
            "#include <vector>",
            "#include <array>",
            "#include <deque>",
            "#include <list>",
            "#include <forward_list>",
            "#include <set>",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include <stack>",
            "#include <queue>",
            "#include <algorithm>",
            "#include <numeric>",
            "#include <cmath>",
            "#include <limits>",
            "#include <memory>",
            "#include <typeinfo>",
            "#include <optional>",
            "#include <variant>",
            "#include <any>",
            "#include <tuple>",
            "#include <utility>",
            "#include <initializer_list>",
            "#include <bitset>",
            "#include <complex>",
            "#include <valarray>",
            "#include <random>",
            "#include <chrono>",
            "#include <ctime>",
            "#include <locale>",
            "#include <codecvt>",
            "#include <regex>",
            "#include <thread>",
            "#include <mutex>",
            "#include <future>",
            "#include <condition_variable>",
            "#include <atomic>",
            "#include <exception>",
            "#include <stdexcept>",
            "#include <system_error>",
            "#include <cerrno>",
            "#include <cfenv>",
            "#include <cfloat>",
            "#include <cinttypes>",
            "#include <climits>",
            "#include <clocale>",
            "#include <csetjmp>",
            "#include <csignal>",
            "#include <cstdarg>",
            "#include <cstdbool>",
            "#include <cstddef>",
            "#include <cstdint>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <ctime>",
            "#include <cwchar>",
            "#include <cwctype>",
            "#include <cuchar>",
            "#include <ciso646>",
            "#include <cstdalign>",
            "#include <functional>",
            ""
        ],
        "description": "Include all standard C++ library headers"
    },
    "5 Constructors (Move/Copy)": {
        "prefix": "task_5constructors",
        "body": [
            "${1:ClassName}() = default;",
            "${1:ClassName}(const ${1:ClassName}& other) = default;",
            "${1:ClassName}(${1:ClassName}&& other) noexcept = default;",
            "${1:ClassName}& operator=(const ${1:ClassName}& other) = default;",
            "${1:ClassName}& operator=(${1:ClassName}&& other) noexcept = default;",
            "~${1:ClassName}() = default;"
        ],
        "description": "Generate default, copy, and move constructors/assignment operators and destructor for a class"
    },
    
    "Class with interface": {
        "prefix": "task_class",
        "body": [
            "class I${1:ClassName} {",
            "public:",
            "    virtual ~I${1:ClassName}() = default;",
            "};",
            "// std::shared_ptr<I${1:ClassName}> ${1:classname};",
            "",
            "class ${1:ClassName} : public I${1:ClassName} {",
            "   struct Impl;",
            "   std::unique_ptr<Impl> pimpl;",
            "public:",
            "};",
            "",
            "//#include \"task.hpp\"",
            "",
            "//namespace task{",
            "//   struct ${1:ClassName}::Impl {",
            "//       std::shared_ptr<SharedData> sd;",
            "//       std::shared_ptr<Interfaces> ifc;",
            "//   };",
            "//}", 
            "/*Generate ${1:ClassName}.cpp file with:",
            "  Windows Power Shell: echo. > task/${1:ClassName}.cpp",
            "  Linux: echo \"\" > task/${1:ClassName}.cpp",
            "*/"
        ],
        "description": "Generate a class with a pure virtual interface method"
    },
}